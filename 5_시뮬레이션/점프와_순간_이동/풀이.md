## 첫 풀이
```java
/*
1. 처음에 점프 & 순간이동 조합으로 2부터 시작한다. 값 기본은 1
2. 2배 해서 재귀, 하나 더해서 재귀한다.
3. 커지면 return으로 이전으로 되돌아간다.
4. 같아지면 값 갱신.
*/

import java.util.*;
import java.lang.*;

public class Solution {
    public static int answer;
    
    public void dfs(int n, int dist, int battery){
        if(dist > n){
            return;
        }
        
        if(dist == n){
            answer = Math.min(answer, battery);
            return;
        }
        
        dfs(n, dist*2, battery);
        dfs(n, dist+1, battery+1);
    }
    
    public int solution(int n) {
        answer = Integer.MAX_VALUE;
        dfs(n, 2, 1);

        return answer;
    }
}
```
- 처음에는 모든 경우의 수를 구해야 한다고 생각해서 이렇게 이중 재귀로 풀었는데
- 사실상 이러면 시간 복잡도가 너무 커지기 때문에 비효율적이다 (반복을 너무 많이 한다,)
- 그래서 최적화가 필요하다. 시간을 줄이기 위해
- 순간이동을 최대한 활용하는 방향으로 가야 하기에, 이 문제는 이게 짝수인지 홀수인지만 구분하면 된다.
    - 그러니까 거꾸로 가면서, 홀수면 1을 빼고 짝수면 2를 나누는 방식으로 가야 순간이동을 최대한 활용할 수 있다.

## 최종 풀이
```java
/*
1. 거꾸로 가면서 홀수면 -1을 하고
2. 짝수면 /2를 한다
3. 그럼 그게 최소이다.
*/

import java.util.*;

public class Solution {
    public int solution(int n) {
        int ans = 1;

        while(n > 2){
            if(n % 2 == 0){
                 n /= 2;
            }else{
                n--;
                ans++;
            }
        }

        return ans;
    }
}
```

```
>> 정확성  테스트

테스트 1 〉	통과 (0.02ms, 85.3MB)
테스트 2 〉	통과 (0.02ms, 81.4MB)
테스트 3 〉	통과 (0.01ms, 90.1MB)
테스트 4 〉	통과 (0.01ms, 80MB)
테스트 5 〉	통과 (0.02ms, 89.1MB)
테스트 6 〉	통과 (0.02ms, 80.5MB)
테스트 7 〉	통과 (0.01ms, 70MB)
테스트 8 〉	통과 (0.01ms, 89.3MB)
테스트 9 〉	통과 (0.02ms, 75MB)
테스트 10 〉	통과 (0.02ms, 84.5MB)
테스트 11 〉	통과 (0.01ms, 86.2MB)
테스트 12 〉	통과 (0.01ms, 88.7MB)
테스트 13 〉	통과 (0.02ms, 80.9MB)
테스트 14 〉	통과 (0.01ms, 86.6MB)
테스트 15 〉	통과 (0.02ms, 79.7MB)
테스트 16 〉	통과 (0.01ms, 82.5MB)
테스트 17 〉	통과 (0.02ms, 92.8MB)
테스트 18 〉	통과 (0.01ms, 75.3MB)

>> 효율성  테스트

테스트 1 〉	통과 (0.02ms, 54.1MB)
테스트 2 〉	통과 (0.02ms, 62.5MB)
테스트 3 〉	통과 (0.02ms, 53.8MB)
테스트 4 〉	통과 (0.03ms, 54.4MB)
테스트 5 〉	통과 (0.02ms, 54.1MB)
테스트 6 〉	통과 (0.02ms, 53.3MB)
테스트 7 〉	통과 (0.02ms, 53.5MB)
테스트 8 〉	통과 (0.02ms, 54MB)
테스트 9 〉	통과 (0.01ms, 54.8MB)
테스트 10 〉	통과 (0.02ms, 53.9MB)

>> 채점 결과

정확성: 60.0
효율성: 40.0
합계: 100.0 / 100.0
```

## 🚨 내가 놓친 부분 정리
1. 때로는 거꾸로 생각해야 할 때도 있다.
- 순방향 1 > n이면 경우의 수가 너무 많지만,
- 역방향 n > 1이면 경우의 수가 확 줄어든다.

**언제 거꾸로 풀까?**

- 목표 지점에서 선택지가 명확하게 분기되어 있을 때
- 순방향으로 보면 분기가 많지만, 역방향으로 보면 분기가 적을 때

2. 재귀 분기의 경우, 시간 복잡도가 기하급수적으로 늘어날 수 있다.

- 이게 매 단계마다 2갈래 → O(2^depth) 😱

**조심 해야 할 신호**

- 재귀 호출이 2개 이상
- 중복 계산 가능성 (같은 상태 재방문)
- 메모이제이션 없이 단순 완전탐색

------

## 😗 추가 ) 재밌는 풀이

```java
import java.util.*;

public class Solution {
    public int solution(int n) {
        return Integer.bitCount(n);
    }
}
```
- bitCount는 정수의 이진 표현에서 1의 개수를 세는 메서드이다.
- 순간이동을 최대한 활용하는 방법은 결국 n을 이진수로 표현했을 때 1의 개수와 같다. (결국 거꾸로 가면서 구한것도 2로 안 나눠지는 1의 갯수 구한거라..)
- 예를 들어 n = 13 (1101) 이면, 순간이동 3번 (2^3 = 8) + 1번 이동 (1) = 4번 이동이 필요하다.
- 따라서 이 문제는 결국 n의 이진 표현에서 1의 개수를 세는 문제로 귀결된다...오옹!