## 첫 풀이
```java
import java.lang.*;
import java.util.*;

class Solution {
    public static int ans = 0;

    public HashSet<Integer> makeSet(int start, int end, int[] topping){
        HashSet<Integer> set = new HashSet<Integer>();
        for(int i = start; i<end; i++){
            set.add(topping[i]);
        }
        return set;
    }
    
    public void cutRollCake(int mid, int[] topping){
        // 5. end == -1이거나 end == n-1이면 return으로 종료
        if(mid == 0 || mid == topping.length){
            return;
        }
        // 2. end로 왼쪽(미포함), 오른쪽 나눈다.
        Set<Integer> setA = makeSet(0, mid, topping);
        Set<Integer> setB = makeSet(mid, topping.length, topping);

        // 3. 왼쪽 set == 오른쪽 set이면 통과
        if(setA.size() == setB.size()){
            ans++;
        }
        // 4. end-1한거랑 end+1 한거를 mid로 두고 재귀한다
        cutRollCake(mid+1, topping);
        cutRollCake(mid-1, topping);
    }
    
    public int solution(int[] topping) {
        // 1. 가운데 기준으로 end 값을 구한다.
        int mid = topping.length / 2;
        // 방문 체크를 해야 같은 곳 방문을 안한다.
        isVisit = new boolean[topping.length];
        cutRollCake(mid, topping);
        
        // 6. ans return 한다.
        return ans;
    }
}
```

- 이렇게 푼 것은, 당연히 수가 같을 확률이 큰건 가운데부터 라고 생각했고
- 그렇기에 가운데부터 양 옆으로 확장해가며 수를 채워나갔다.
- 여기서 문제가 되었던건 StackOverflowError 였는데,
- 이는 재귀함수를 사용하기 때문에, 호출 된 것이 또 호출되는 것이 문제엿다.

```
cutRollCake(5)
├─ cutRollCake(6)
│  ├─ cutRollCake(7)
│  └─ cutRollCake(5)  ← 다시 5로 돌아옴!
│     ├─ cutRollCake(6)  ← 무한 반복
│     └─ cutRollCake(4)
└─ cutRollCake(4)
   ├─ cutRollCake(5)  ← 또 5로 돌아옴!
   └─ cutRollCake(3)
```

## 다시 풀이
```java
import java.lang.*;
import java.util.*;

class Solution {
    public static int ans = 0;
    public static boolean[] isVisit;
    
    public HashSet<Integer> makeSet(int start, int end, int[] topping){
        HashSet<Integer> set = new HashSet<Integer>();
        for(int i = start; i<end; i++){
            set.add(topping[i]);
        }
        return set;
    }
    
    public void cutRollCake(int mid, int[] topping){
        // 5. end == -1이거나 end == n-1이면 return으로 종료
        if(mid == 0 || mid == topping.length){
            return;
        }
        
        // 이미 방문 했으면 종료
        if(isVisit[mid]){
            return;
        }
        
        isVisit[mid] = true;    // 방문 체크
        
        // 2. end로 왼쪽(미포함), 오른쪽 나눈다.
        Set<Integer> setA = makeSet(0, mid, topping);
        Set<Integer> setB = makeSet(mid, topping.length, topping);

        // 3. 왼쪽 set == 오른쪽 set이면 통과
        if(setA.size() == setB.size()){
            ans++;
        }
        // 4. end-1한거랑 end+1 한거를 mid로 두고 재귀한다
        cutRollCake(mid+1, topping);
        cutRollCake(mid-1, topping);
    }
    
    public int solution(int[] topping) {
        // 1. 가운데 기준으로 end 값을 구한다.
        int mid = topping.length / 2;
        // 방문 체크를 해야 같은 곳 방문을 안한다.
        isVisit = new boolean[topping.length];
        cutRollCake(mid, topping);
        
        // 6. ans return 한다.
        return ans;
    }
}
```
- 그래서 방문 체크 배열을 만들어서, 이미 방문한 곳은 가지 않도록 하였다.
- 그랬더니 레전드 시간초과 이슈가 발생하였다...

```
테스트 1 〉	통과 (2256.83ms, 419MB)
테스트 2 〉	실패 (시간 초과)
테스트 3 〉	실패 (시간 초과)
테스트 4 〉	실패 (시간 초과)
테스트 5 〉	실패 (시간 초과)
테스트 6 〉	실패 (시간 초과)
테스트 7 〉	실패 (시간 초과)
테스트 8 〉	실패 (시간 초과)
테스트 9 〉	실패 (시간 초과)
테스트 10 〉	실패 (시간 초과)
테스트 11 〉	실패 (시간 초과)
테스트 12 〉	통과 (4588.75ms, 623MB)
테스트 13 〉	실패 (시간 초과)
테스트 14 〉	실패 (시간 초과)
테스트 15 〉	실패 (시간 초과)
테스트 16 〉	실패 (시간 초과)
테스트 17 〉	실패 (시간 초과)
테스트 18 〉	실패 (시간 초과)
테스트 19 〉	실패 (시간 초과)
테스트 20 〉	실패 (시간 초과)
```

내 생에 저런 시간은 처음본다.

-------

## 조언 (풀이)

- 이 문제는 단순히 가운데서부터 확장해 나가는게 아니라,
- 슬라이딩 윈도우를 써야 한다고 한다.
- 까먹은 개념이라..내일 다시 해보기로 했다.