## 첫 풀이
```java
import java.util.*;
import java.lang.*;

class Solution {
    public static final int binary = 2;
    
    public String changeBinary(int length){
        StringBuilder stb = new StringBuilder();
        // 1. 몫이 나누는 수보다 더 작다면 끝낸다.
        while(length >= binary){
            // 2. 나머지를 올리고, 수는 계속 나눈다.
            stb.append(length % binary);
            length /= binary;
        }
        // 3. 마지막에 몫을 올린다.
        stb.append(length);
        
        return stb.reverse().toString();
    }
    
    public void addZeroCnt(ArrayList<Integer> answerList, String s){
        int preLen = s.length();
        // 1. replace로 0을 제거한다.
        s = s.replace("0", "");
        // 2. 이전 length()와 비교해서 0을 누적한다.
        int afterLen = preLen - s.length();
        
        answerList.add(afterLen);
    }
    
    public int[] solution(String s) {
        int[] answer = {};
        ArrayList<Integer> answerList = new ArrayList<Integer>();
        
        // 4. 이 과정을 s가 1이 될때까지 반복
        while(!("1".equals(s))){
            addZeroCnt(answerList, s);
            // 3. 이진 변환한다
            s = changeBinary(s.length());
        }
        
        // 5. int[]로 변환해서 answer에 담는다.
        answer = answerList.stream()
            .mapToInt(Integer::intValue).toArray();
        
        return answer;
    }
}
```
- 의미상 맞는거 같은데
- 왜 메모리 초과..?
- 아무래도 while문쪽 문제 같달까

## 풀이
```java
import java.util.*;
import java.lang.*;

class Solution {
    public static final int binary = 2;
    
    public String changeBinary(int length){
        StringBuilder stb = new StringBuilder();
        // 1. 몫이 나누는 수보다 더 작다면 끝낸다.
        while(length >= binary){
            // 2. 나머지를 올리고, 수는 계속 나눈다.
            stb.append(length % binary);
            length /= binary;
        }
        // 3. 마지막에 몫을 올린다.
        stb.append(length);
        
        return stb.reverse().toString();
    }

    public int[] solution(String s) {
        int[] answer = new int[2];
        int zeroCnt = 0;
        int binaryCnt = 0;
        
        // 4. 이 과정을 s가 1이 될때까지 반복
        while(!("1".equals(s))){
            int preLen = s.length();
            // 1. replace로 0을 제거한다.
            s = s.replace("0", "");
            // 2. 이전 length()와 비교해서 0을 누적한다.
            zeroCnt += preLen - s.length();
            // 3. 이진 변환한다
            s = changeBinary(s.length());
            binaryCnt++;
        }
        
        answer[0] = binaryCnt;
        answer[1] = zeroCnt;
        
        return answer;
    }
}
```

- 아...민망하게도 문제 자체를 잘못 이해함!!!
- 이거 stream 쓸 필요도 없는게, 이진변환 횟수랑 0 개수 누적만 하면 되는거였음
- 문제 좀 잘 읽자 진짜 ㅠㅠ!!!!!줴발!!!!!!

### 정확성 테스트
```java
테스트 1 〉	통과 (0.09ms, 76MB)
테스트 2 〉	통과 (7.90ms, 93.4MB)
테스트 3 〉	통과 (0.05ms, 83.2MB)
테스트 4 〉	통과 (0.06ms, 82.9MB)
테스트 5 〉	통과 (0.05ms, 77.3MB)
테스트 6 〉	통과 (0.16ms, 86.7MB)
테스트 7 〉	통과 (0.19ms, 84.2MB)
테스트 8 〉	통과 (0.20ms, 85.6MB)
테스트 9 〉	통과 (2.48ms, 88.5MB)
테스트 10 〉	통과 (6.93ms, 77MB)
테스트 11 〉	통과 (6.08ms, 91.3MB)
```