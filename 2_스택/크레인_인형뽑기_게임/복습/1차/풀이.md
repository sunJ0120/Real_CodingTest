## 풀이
### 사고 > 계획
![](풀이.jpg)

```java
import java.util.*;
import java.lang.*;

class Solution {
    public int solution(int[][] board, int[] moves) {
        int answer = 0;
        // 1. 열 하나하나를 스택으로 만든다.
        List<ArrayDeque<Integer>> crain = new ArrayList<ArrayDeque<Integer>>();
        ArrayDeque<Integer> bucket = new ArrayDeque<Integer>();
        
        for(int m = 0; m<board[0].length; m++){
            ArrayDeque<Integer> stack = new ArrayDeque<Integer>();
            for(int n = board.length-1; n>=0; n--){
                if(board[n][m] == 0){
                    break;
                }
                stack.push(board[n][m]);
            }
            crain.add(stack);
        }
        // 2. 위치에 맞게 pop으로 가져온다. (거꾸로)
        for(int move : moves){
            // 3. 위치에 따라 (-1해서 인덱스 맞추기) 가져오면서 맞춰본다.
            ArrayDeque<Integer> stack = crain.get(move-1);
            if(stack.isEmpty()){
                continue;
            }
            
            int doll = stack.pop();
            if(!bucket.isEmpty() && bucket.peek() == doll){
                // 4. 터지면 두개씩 증가
                answer+=2;
                bucket.pop();
            }else{
                bucket.push(doll);
            }
        }
        return answer;
    }
}
```
### 정확도
```java
테스트 1 〉	통과 (0.10ms, 81.5MB)
테스트 2 〉	통과 (0.09ms, 70.2MB)
테스트 3 〉	통과 (0.12ms, 81MB)
테스트 4 〉	통과 (1.15ms, 81.7MB)
테스트 5 〉	통과 (0.07ms, 85.1MB)
테스트 6 〉	통과 (0.09ms, 69.5MB)
테스트 7 〉	통과 (0.27ms, 88.9MB)
테스트 8 〉	통과 (0.78ms, 80.2MB)
테스트 9 〉	통과 (0.85ms, 80.3MB)
테스트 10 〉	통과 (0.68ms, 85.7MB)
테스트 11 〉	통과 (0.84ms, 84.4MB)
```
### 아쉬운점
계획 짜는 과정에서 예외에 대한 부분 처리를 잘 못함
특히 이 문제의 경우는, Stack이 비어 있는 경우에 대한 처리를 잘 해야 하고
컬렉션을 이중으로 써야해서 헷갈림

앞으로 이런일이 있으면, 그냥 컬렉션을 이중으로 안쓰고 배열 & 컬렉션으로 쓰는게 더 안 헷갈릴듯 싶다.