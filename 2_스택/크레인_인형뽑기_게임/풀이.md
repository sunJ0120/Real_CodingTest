## 풀이

### 첫 풀이

```java
import java.util.*;
import java.lang.*;

class Solution {
    public int solution(int[][] board, int[] moves) {
        int answer = 0;
        // 1. 스택 정의하기
        Deque<Integer> stack = new ArrayDeque<Integer>();
        
        // 2. 깊이 배열 정의하기
        int[] depth = new int[board[0].length];
        
        // 3. 높이 저장하기
        for(int j = 0; j<board[0].length; j++){ //렬
            for(int i = 0; i<board.length; i++){ //행
                if(board[i][j] == 0){
                    depth[j]++;
                }else{
                    break;
                }
            }
        }
        
        // 4. moves를 열로 하면서 맨 위에서부터 하나씩 빼기
        for(int move : moves){
            if(depth[move-1] >= board.length){
                continue;
            }
            
            int dolls = board[depth[move-1]][move-1];
            
            if(stack.isEmpty() || stack.peek() != dolls){
                stack.push(dolls);
                depth[move-1]++; // 깊이 증가
                continue;
            }else{
                // 5. 스택의 top과 같은지 보고 빼기
                stack.pop();
                answer += 2;
            }
        }
        return answer;
    }
}
```

- 왜 틀릴까…? 진짜 이유를 모르겠네

```java
정확성  테스트

테스트 1 〉	실패 (0.07ms, 85.6MB)
테스트 2 〉	실패 (0.08ms, 80.6MB)
테스트 3 〉	통과 (0.07ms, 73.9MB)
테스트 4 〉	통과 (0.51ms, 85.7MB)
테스트 5 〉	통과 (0.06ms, 80.5MB)
테스트 6 〉	실패 (0.06ms, 75MB)
테스트 7 〉	실패 (0.16ms, 76.5MB)
테스트 8 〉	실패 (0.53ms, 90.1MB)
테스트 9 〉	실패 (0.22ms, 82.7MB)
테스트 10 〉	실패 (0.41ms, 93.9MB)
테스트 11 〉	실패 (0.49ms, 73.8MB)

채점 결과

정확성: 27.3
합계: 27.3 / 100.0
```

아!!! 어쨌든 바구니에 담는것도 인형을 뽑는거니까 depth를 증가시켜야 한다.

### 고친 풀이

```java
import java.util.*;
import java.lang.*;

class Solution {
    public int solution(int[][] board, int[] moves) {
        int answer = 0;
        // 1. 스택 정의하기
        Deque<Integer> stack = new ArrayDeque<Integer>();
        // 2. 깊이 배열 정의하기
        int[] depth = new int[board[0].length];
        // 3. 높이 저장하기
        for(int j = 0; j<board[0].length; j++){ //렬
            for(int i = 0; i<board.length; i++){ //행
                if(board[i][j] == 0){
                    depth[j]++;
                }else{
                    break;
                }
            }
        }
        
        // 4. moves를 열로 하면서 맨 위에서부터 하나씩 빼기
        for(int move : moves){
            if(depth[move-1] >= board.length){
                continue;
            }
            
            int dolls = board[depth[move-1]][move-1];
            depth[move-1]++; // 깊이는 항상 증가
            
            if(stack.isEmpty() || stack.peek() != dolls){
                stack.push(dolls);
                continue;
            }else{
                // 5. 스택의 top과 같은지 보고 빼기
                stack.pop();
                answer += 2;
            }
        }
        return answer;
    }
}
```

```java
정확성  테스트

테스트 1 〉	통과 (0.05ms, 76MB)
테스트 2 〉	통과 (0.06ms, 69.1MB)
테스트 3 〉	통과 (0.11ms, 83.6MB)
테스트 4 〉	통과 (0.59ms, 72MB)
테스트 5 〉	통과 (0.06ms, 86.3MB)
테스트 6 〉	통과 (0.06ms, 81.7MB)
테스트 7 〉	통과 (0.11ms, 76.7MB)
테스트 8 〉	통과 (0.40ms, 73.2MB)
테스트 9 〉	통과 (0.35ms, 72.7MB)
테스트 10 〉	통과 (0.45ms, 76.3MB)
테스트 11 〉	통과 (0.51ms, 90.6MB)

채점 결과

정확성: 100.0
합계: 100.0 / 100.0
```

일부러 메모리 줄이려고 stack 열만큼 안쓴건데….

참고 풀이에선 **열 만큼 스택을 쓰라** 그래서, 나의 depth 방식과 비교하기로

### 크레인 인형뽑기 문제 - 두 가지 접근법 비교

1. 여러 스택 사용 (열별 스택)

```java
// 각 열을 스택으로 관리
Stack<Integer>[] columns = new Stack[n];
for(int i = 0; i < n; i++) {
    columns[i] = new Stack<>();
    for(int j = board.length-1; j >= 0; j--) {
        if(board[j][i] != 0) {
            columns[i].push(board[j][i]);
        }
    }
}
```

2. Depth 배열 사용 (메모리 최적화)

```java
int[] depth = new int[board[0].length];
// board를 직접 참조하며 depth로 위치 관리
```

### 비교 분석표

| 측면 | 여러 스택 | depth 배열 |
| --- | --- | --- |
| **메모리** | ❌ O(N×M) | ✅ O(N) |
| **속도** | O(N×M + K) | O(N×M + K) |
| **가독성** | ✅ 매우 좋음 | ⭕ 보통 |
| **실수 가능성** | ✅ 낮음 | ⭕ 중간 |

### 각 방식의 장단점

여러 스택 방식

**장점:**

- 직관적이고 이해하기 쉬움
- 실수할 여지가 적음
- 코드가 더 깔끔함

**단점:**

- 메모리 사용량이 많음 (모든 인형 복사)

Depth 배열 방식

**장점:**

- 메모리 효율적 (O(N)만 사용)
- 원본 board를 그대로 활용
- 실제 크레인 게임의 동작과 유사

**단점:**

- 인덱스 관리가 복잡함
- depth 업데이트 타이밍 실수 가능

### 결론 및 추천

### 📝 코딩 테스트

**Depth 배열 방식 추천**

- 메모리 효율성이 중요한 평가 요소
- 공간 복잡도 최적화 점수 획득 가능

### 💼 실무 프로젝트

**여러 스택 방식 추천**

- 유지보수와 가독성이 최우선
- 팀 협업 시 이해하기 쉬운 코드가 중요

---

**💡 핵심 포인트**: Depth 배열 방식은 코딩 테스트에 적합하지만, 인덱스 관리와 depth 업데이트 타이밍에 특별히 주의해야 함

> 즉, 나의 경우도 사실상 인덱스 때문에 애먹은건 맞아서 실수만 주의하라~