## 풀이

### 내 풀이

```java
import java.util.*;
import java.lang.*;

class Solution {
    public int solution(String s) {
        int answer = 0;
        StringBuilder stb = new StringBuilder(s);
        Deque<Character> stack = new ArrayDeque<Character>();
        
        // 문자열 길이만큼 검사
        for(int i = 0; i<stb.length(); i++){
            int cnt = 0;
            // 괄호 체크
            for(int j = 0; j<stb.length(); j++){
                if(stb.charAt(j) == '[' || stb.charAt(j) == '{'|| stb.charAt(j) == '('){
                    stack.addLast(stb.charAt(j));
                }else{
                    if(stack.isEmpty()){
                        break;
                    }else if(stack.peekLast() == '[' && stb.charAt(j) == ']' || stack.peekLast() == '(' && stb.charAt(j) == ')' || stack.peekLast() == '{' && stb.charAt(j) == '}'){
                        cnt++;
                        stack.pollLast();
                    }else{
                        break;
                    }
                }
            }
            
            if(cnt == s.length()/2){
                answer++;
            }
            
            // 왼쪽으로 돌리기
            stb.append(stb.charAt(0));
            stb.deleteCharAt(0);
        }
        return answer;
    }
}
```

### 결과

```sql
테스트 1 〉	통과 (11.21ms, 82.9MB)
테스트 2 〉	통과 (7.33ms, 78.3MB)
테스트 3 〉	통과 (8.17ms, 85.5MB)
테스트 4 〉	통과 (15.91ms, 77MB)
테스트 5 〉	통과 (22.44ms, 78.6MB)
테스트 6 〉	통과 (13.37ms, 73MB)
테스트 7 〉	통과 (16.35ms, 89.7MB)
테스트 8 〉	통과 (23.07ms, 75.7MB)
테스트 9 〉	통과 (26.89ms, 92.2MB)
테스트 10 〉	통과 (32.38ms, 82.8MB)
테스트 11 〉	통과 (35.84ms, 88.9MB)
테스트 12 〉	실패 (0.06ms, 87.5MB)
테스트 13 〉	실패 (0.14ms, 82MB)
테스트 14 〉	통과 (0.14ms, 79MB)
```

### 주의 사항

#### Deque의 메서드 동작 방식

```java
Deque<Character> deque = new ArrayDeque<>();
deque.add('A');  *// [A]*
deque.add('B');  *// [A, B]*
deque.add('C');  *// [A, B, C]// Stack처럼 사용하려면 (LIFO - 뒤쪽 기준):*
deque.addLast('D');   *// [A, B, C, D]*
deque.peekLast();     *// 'D' 반환*
deque.pollLast();     *// 'D' 제거하고 반환// 하지만 pop(), peek()은 앞쪽(first) 기준:*
deque.pop();    *// = pollFirst() → 'A' 제거하고 반환*
deque.peek();   *// = peekFirst() → 'B' 반환 (제거 안함)*
```

```java
stack.push(ch);      *// 실제로는 addFirst() → 앞에 추가*
stack.peek();        *// peekFirst() → 가장 앞 요소 확인*
stack.pop();         *// pollFirst() → 가장 앞 요소 제거*
```

이렇게 하면 **큐처럼 동작**해서 괄호 검사가 제대로 안 된다.

스택은 **LIFO(Last In First Out)** 이어야 하는데,

앞쪽 기준으로 동작하면 **FIFO(First In First Out)** 가 되어버린다.

그러므로, deque를 stack처럼 사용할때는 주의하도록 하자.

### 왜 틀렸을까?

| 테스트 8 |  |
| --- | --- |
| 입력값 〉 | "(" |
| 기댓값 〉 | 0 |
| 실행 결과 〉 | 실행한 결괏값 1이 기댓값 0과 다릅니다. |

엣지 케이스 찾았다.

```java
import java.util.*;
import java.lang.*;

class Solution {
    public int solution(String s) {
        int answer = 0;
        StringBuilder stb = new StringBuilder(s);
        Deque<Character> stack = new ArrayDeque<Character>();
        
        // 홀수 일 경우, 바로 false
        if(stb.length()%2 != 0){
            return answer;
        }
        
        // 문자열 길이만큼 검사
        for(int i = 0; i<stb.length(); i++){
            boolean flag = true;
            // 괄호 체크
            for(int j = 0; j<stb.length(); j++){
                if(stb.charAt(j) == '[' || stb.charAt(j) == '{'|| stb.charAt(j) == '('){
                    stack.addLast(stb.charAt(j));
                }else{
                    if(stack.isEmpty()){
                        flag = false; //중간에 끊긴걸 표현하기 위한 플래그
                        break;
                    }else if(stack.peekLast() == '[' && stb.charAt(j) == ']' || stack.peekLast() == '(' && stb.charAt(j) == ')' || stack.peekLast() == '{' && stb.charAt(j) == '}'){
                        stack.pollLast();
                    }else{
                        flag = false;
                        break;
                    }
                }
            }
            
            if(flag){
                answer++;
            }
            
            // 왼쪽으로 돌리기
            stb.append(stb.charAt(0));
            stb.deleteCharAt(0);
        }
        
        return answer;
    }
}
```

홀수일 경우는 무조건 괄호가 안 맞는거라 바로 뺐는데, 풀이 방식이…마음에 안든다 너무 드럽다.

```java
정확성  테스트

테스트 1 〉	통과 (13.32ms, 72.4MB)
테스트 2 〉	통과 (7.60ms, 106MB)
테스트 3 〉	통과 (5.89ms, 76.4MB)
테스트 4 〉	통과 (9.96ms, 93.1MB)
테스트 5 〉	통과 (32.70ms, 91.9MB)
테스트 6 〉	통과 (19.80ms, 88.6MB)
테스트 7 〉	통과 (16.23ms, 86.2MB)
테스트 8 〉	통과 (14.71ms, 88.3MB)
테스트 9 〉	통과 (26.50ms, 92.1MB)
테스트 10 〉	통과 (32.87ms, 79.6MB)
테스트 11 〉	통과 (34.18ms, 80.4MB)
테스트 12 〉	통과 (0.04ms, 73.3MB)
테스트 13 〉	통과 (0.06ms, 81.5MB)
테스트 14 〉	통과 (0.14ms, 77.1MB)
```

### 참고 풀이

- 아 이 풀이에서 눈여겨 봐야 할 점은 이거다.
1. Map을 이용해서 괄호의 짝을 저장하는 방식으로 지저분한 비교 코드를 삭제 및 여러개의 괄호들도 처리 가능하도록 함
2. 문자열을 두 개 이어붙여서 뒤로 직접 옮길 필요 없이 i 이동 만으로 처리

어떻게 이런 천재적인 생각을…?

```java
import java.util.*;
import java.lang.*;

class Solution { 
    // 괄호 init을 위한 method
    public HashMap<Character,Character> init(HashMap<Character,Character> map){
        map.put('(',')');
        map.put('{','}');
        map.put('[',']');
        
        return map;
    }
    public int solution(String s) {
        int answer = 0;
        // 1. 괄호 짝 맞추기
        HashMap<Character,Character> map = new HashMap<Character,Character>(); // map으로 괄호 짝 저장하기
        map = init(map);
        s+=s; // string을 이어 붙여서 i 움직여서 **뒤로 간 것 같은 효과**주기
    
        Deque<Character> stack = new ArrayDeque<Character>(); // 가장 최근 것을 매칭하기 위해 stack 개념 활용
        
        for(int i = 0; i<s.length()/2; i++){ //시작점
            boolean flag = true;
            for(int j = i; j<(s.length()/2)+i; j++){
                if(map.containsKey(s.charAt(j))){ //시작 괄호
                    stack.push(s.charAt(j));
                }else{
                    // 짝이 없을 경우
                    if(stack.isEmpty() || !map.get(stack.pop()).equals(s.charAt(j))){
                        flag = false;
                        break;
                    }
                }
            }
            if(flag && stack.isEmpty()){
                answer++;
            }
        }
        // 2. 짝이 맞을 경우의 수를 추가한다.
        return answer;
    }
}
```

```java
정확성  테스트

테스트 1 〉	통과 (16.10ms, 89.1MB)
테스트 2 〉	통과 (11.86ms, 76.4MB)
테스트 3 〉	통과 (10.08ms, 94.1MB)
테스트 4 〉	통과 (10.95ms, 78.8MB)
테스트 5 〉	통과 (26.34ms, 77.9MB)
테스트 6 〉	통과 (17.71ms, 84.3MB)
테스트 7 〉	통과 (19.38ms, 77.7MB)
테스트 8 〉	통과 (21.33ms, 93.6MB)
테스트 9 〉	통과 (32.35ms, 83.4MB)
테스트 10 〉	통과 (35.53ms, 77.8MB)
테스트 11 〉	통과 (36.22ms, 91MB)
테스트 12 〉	통과 (1.27ms, 89.1MB)
테스트 13 〉	통과 (1.82ms, 82.2MB)
테스트 14 〉	통과 (1.19ms, 87.1MB)
```

조금 느리긴 하지만, 확실히 확장성 면에서도 좋고

코드 품질이 훨씬 일관적이고, 향상된 느낌이라 이 풀이가 더 좋은거 같다.