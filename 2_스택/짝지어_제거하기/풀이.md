## 풀이

```java
import java.util.*;
import java.lang.*;

class Solution
{
    public int solution(String s)
    {
        Deque<Character> stack = new ArrayDeque<Character>();
        
        for(char ch : s.toCharArray()){
            if(stack.isEmpty() || stack.peek() != ch){ // 1. 하나씩 올린다.
                stack.push(ch);
            }else{
                while(!stack.isEmpty() && stack.peek() == ch){
                    // 2. 가장 최근것과 비교해서, 같으면 다를 때까지 pop한다.
                    stack.pop();
                }
            }
        }
        
        if(stack.isEmpty()){
            return 1;
        }else{
            return 0;
        }
    }
}
```

```java
정확성  테스트

테스트 1 〉	통과 (0.11ms, 87.7MB)
테스트 2 〉	통과 (13.30ms, 85.8MB)
테스트 3 〉	통과 (16.59ms, 83.9MB)
테스트 4 〉	통과 (16.74ms, 75.9MB)
테스트 5 〉	통과 (16.90ms, 88.3MB)
테스트 6 〉	통과 (17.16ms, 86.8MB)
테스트 7 〉	통과 (20.60ms, 86.5MB)
테스트 8 〉	통과 (17.97ms, 92.2MB)
테스트 9 〉	통과 (0.13ms, 93MB)
테스트 10 〉	통과 (0.34ms, 86.1MB)
테스트 11 〉	통과 (0.15ms, 76.2MB)
테스트 12 〉	통과 (0.11ms, 86.1MB)
테스트 13 〉	통과 (0.11ms, 86.6MB)
테스트 14 〉	통과 (0.18ms, 88.2MB)
테스트 15 〉	통과 (0.17ms, 76.5MB)
테스트 16 〉	통과 (0.12ms, 86.8MB)
테스트 17 〉	통과 (0.12ms, 79.4MB)
테스트 18 〉	통과 (0.11ms, 85.5MB)

효율성  테스트

테스트 1 〉	통과 (60.20ms, 66.3MB)
테스트 2 〉	통과 (37.79ms, 61.1MB)
테스트 3 〉	통과 (81.29ms, 79.8MB)
테스트 4 〉	통과 (73.60ms, 62.7MB)
테스트 5 〉	통과 (74.04ms, 62.7MB)
테스트 6 〉	통과 (52.76ms, 62.6MB)
테스트 7 〉	통과 (69.42ms, 63.4MB)
테스트 8 〉	통과 (75.19ms, 64.3MB)

채점 결과

정확성: 61.2
효율성: 38.8
합계: 100.0 / 100.0
```

- 뭔가 로직이 비 효율적인것 같아서…..더 좋은 방법이 있을 것 같음.

## 참고 풀이 (10-15)

이거 왜 이렇게 풀었지…? 사실상 while을 돌릴 필요가 없고, 같으면 다음에도 pop 하고, 다르면 push 하고만 반복하면 된다. 사실상 for 한 번이면 해결이 가능한 것

항상 너무 복잡하게 생각하지 마라!

### 다시 풀이

```java
import java.util.*;
import java.lang.*;

class Solution
{
    public int solution(String s)
    {
        Deque<Character> stack = new ArrayDeque<Character>();
        
        for(char ch : s.toCharArray()){
            if(!stack.isEmpty() && stack.peek() == ch){ 
                stack.pop();
            }else{
                stack.push(ch);
            }
        }
        
        if(stack.isEmpty()){
            return 1;
        }else{
            return 0;
        }
    }
}
```

```java
정확성  테스트

테스트 1 〉	통과 (0.16ms, 73.7MB)
테스트 2 〉	통과 (16.63ms, 77.9MB)
테스트 3 〉	통과 (27.98ms, 75.1MB)
테스트 4 〉	통과 (26.04ms, 94.3MB)
테스트 5 〉	통과 (14.21ms, 90.6MB)
테스트 6 〉	통과 (12.39ms, 85.9MB)
테스트 7 〉	통과 (22.79ms, 88.9MB)
테스트 8 〉	통과 (14.12ms, 89.1MB)
테스트 9 〉	통과 (0.11ms, 91MB)
테스트 10 〉	통과 (0.28ms, 79.1MB)
테스트 11 〉	통과 (0.18ms, 85.2MB)
테스트 12 〉	통과 (0.12ms, 87.8MB)
테스트 13 〉	통과 (0.17ms, 80.9MB)
테스트 14 〉	통과 (0.12ms, 83.8MB)
테스트 15 〉	통과 (0.18ms, 93.1MB)
테스트 16 〉	통과 (0.18ms, 78.1MB)
테스트 17 〉	통과 (0.13ms, 80MB)
테스트 18 〉	통과 (0.16ms, 79.9MB)

효율성  테스트

테스트 1 〉	통과 (57.70ms, 66MB)
테스트 2 〉	통과 (31.78ms, 60.1MB)
테스트 3 〉	통과 (53.97ms, 83.9MB)
테스트 4 〉	통과 (51.95ms, 62.8MB)
테스트 5 〉	통과 (44.81ms, 63.5MB)
테스트 6 〉	통과 (47.72ms, 63.3MB)
테스트 7 〉	통과 (44.62ms, 63.2MB)
테스트 8 〉	통과 (47.63ms, 65MB)

채점 결과

정확성: 61.2
효율성: 38.8
합계: 100.0 / 100.0
```
