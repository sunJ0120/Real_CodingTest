## 풀이

```java
import java.util.*;
import java.lang.*;

class Solution {
    boolean solution(String s) {
        Stack<Character> st = new Stack<Character>();
        int cnt = 0;
        
        // 1. 뒤에서 부터 하나씩 빼서, )인지 본다. )이면 스택에 쌓는다.
        for(int i = s.length()-1; i>=0; i--){
            if(')'== s.charAt(i)){
                st.push(s.charAt(i));
            }else{
                if(st.isEmpty()){
                    return false; //짝이 없으면 바로 return
                }
                // 2. (가 나오면 지운다. 안쪽부터 해결해야 하기 때문에 가장 최근에 들어온 것 부터 지운다.
                st.pop(); 
                cnt++; //짝을 얼만큼 지웠는지 cnt 하기 위함이다.
            }
        }
        
        // 3. 스택에 남아 있는게 있거나 string에 남아 있는게 있는지 본다.
        if(cnt*2 == s.length()){
            return true;
        }

        return false;
    }
}
```

### 결과

```java
정확성  테스트

테스트 1 〉	통과 (0.15ms, 80.2MB)
테스트 2 〉	통과 (0.18ms, 81.5MB)
테스트 3 〉	통과 (0.11ms, 82.7MB)
테스트 4 〉	통과 (0.12ms, 70.1MB)
테스트 5 〉	통과 (0.25ms, 89.5MB)
테스트 6 〉	통과 (0.17ms, 76.3MB)
테스트 7 〉	통과 (0.20ms, 86.2MB)
테스트 8 〉	통과 (0.25ms, 74.6MB)
테스트 9 〉	통과 (0.22ms, 84.4MB)
테스트 10 〉	통과 (0.29ms, 72.1MB)
테스트 11 〉	통과 (0.25ms, 71.9MB)
테스트 12 〉	통과 (0.29ms, 80MB)
테스트 13 〉	통과 (0.27ms, 73MB)
테스트 14 〉	통과 (0.28ms, 77.1MB)
테스트 15 〉	통과 (0.25ms, 85.2MB)
테스트 16 〉	통과 (0.28ms, 80.6MB)
테스트 17 〉	통과 (0.21ms, 86MB)
테스트 18 〉	통과 (0.10ms, 77.9MB)
```

```java
효율성  테스트

테스트 1 〉	통과 (21.53ms, 55MB)
테스트 2 〉	통과 (17.40ms, 55.6MB)
```

```java
채점 결과

정확성: 69.5
효율성: 30.5
합계: 100.0 / 100.0
```

- 이 문제의 포인트는, 닫힌 괄호가 임의 위치의 열린 괄호와 상쇄되는 것이 아니라, 닫힌 괄호가 나오기 바로 전의, 즉 **가장 가까운 (최근) 열린 괄호**와 상쇄된다는 것이다.
- 여기서 가장 최근이라는 키워드를 통해 **스택**을 사용한다는 것을 알아채야 한다.

## 참고 풀이

- 이 문제의 경우, Stack 보다는 Deque를 이용하는 것이 더 좋다.
- 이유는 클래스의 문제점과 연결되는데….다음과 같음.

### Java에서 Stack 클래스의 문제점

### 1. **레거시 클래스 (구식)**

```java
public class Stack<E> extends Vector<E> {
    *// Vector를 상속받음 (1996년 Java 1.0)*
}
```

- Java 1.0 시절 설계 (25년 전!)
- 현대적인 컬렉션 프레임워크 이전 산물

### 2. **불필요한 동기화 오버헤드**

```java
*// Stack의 모든 메서드는 synchronized*
public synchronized E push(E item) { ... }
public synchronized E pop() { ... }
```

- 멀티스레드 안전성 위해 모든 메서드가 `synchronized`
- **단일 스레드에서도 동기화 비용 발생** (불필요한 성능 손실)

### 3. **Vector 상속의 문제**

```java
Stack<Integer> stack = new Stack<>();
stack.push(1);
stack.add(0, 999);  *// 중간에 삽입 가능! 스택 원칙 위반*
stack.get(0);        *// 직접 접근 가능! 스택 원칙 위반*
```

- Vector의 모든 메서드 노출 → **스택 자료구조 원칙 깨짐**

### Deque를 쓰는 이유

### 1. **성능 우수**

```java
Deque<Integer> stack = new ArrayDeque<>();
stack.push(1);  *// synchronized 없음 → 더 빠름*
```

- 동기화 오버헤드 없음
- 내부적으로 배열 기반 (효율적)

### 2. **Java 공식 권장사항**

Java Docs의 Stack 클래스 설명:

> "A more complete and consistent set of LIFO stack operations is provided by the Deque interface and its implementations, which should be used in preference to this class."

### 3. **깔끔한 인터페이스**

```java
Deque<Integer> stack = new ArrayDeque<>();
stack.push(1);   *// 스택처럼 사용*
stack.pop();
stack.peek();
*// Vector의 이상한 메서드들 노출 안 됨*
```

> 그래서 결국, Stack을 이용하는 문제는 Deque를 이용하는 것이 더 좋다는 것이다.

그리고 이 문제 역시, 사실 복잡하게 생각할 것 없이 **가장 최근에 나온 괄호 위주로 지우면 된다.**

즉, 앞에서 부터 가면서 ( 일 경우 deque에 올리고, )가 나왔을때 empty라면 )가 더 많은 것이므로 탈락이고, 다 끝났을때 deque가 empty가 아니라면 (가 더 많고, 짝이 안 맞는 것이므로 탈락이라고 해주면 된다.

즉, 로직을 다음과 같이 간단하게 바꿀 수 있다.

### 수정 풀이

```java
import java.util.*;
import java.lang.*;

class Solution {
    boolean solution(String s) {
        Deque<Character> st = new ArrayDeque<Character>();
        
        for(int i = 0; i<s.length(); i++){
            if(s.charAt(i) == '('){
                st.push(s.charAt(i));
            }else{
                if(st.isEmpty()){ //짝 안맞음 
                    return false;
                }
                st.pop(); //짝 맞음
            }
        }

        return st.isEmpty(); //짝 맞음
    }
}
```

### 결과

```java
정확성  테스트

테스트 1 〉	통과 (0.13ms, 88.9MB)
테스트 2 〉	통과 (0.06ms, 74.5MB)
테스트 3 〉	통과 (0.05ms, 88.9MB)
테스트 4 〉	통과 (0.11ms, 85.7MB)
테스트 5 〉	통과 (0.14ms, 80.9MB)
테스트 6 〉	통과 (0.04ms, 79.7MB)
테스트 7 〉	통과 (0.10ms, 71.4MB)
테스트 8 〉	통과 (0.10ms, 70.6MB)
테스트 9 〉	통과 (0.16ms, 74.9MB)
테스트 10 〉	통과 (0.16ms, 79MB)
테스트 11 〉	통과 (0.11ms, 70.7MB)
테스트 12 〉	통과 (0.25ms, 87.9MB)
테스트 13 〉	통과 (0.24ms, 70.1MB)
테스트 14 〉	통과 (0.18ms, 73.2MB)
테스트 15 〉	통과 (0.16ms, 72.9MB)
테스트 16 〉	통과 (0.24ms, 80.9MB)
테스트 17 〉	통과 (0.18ms, 78.7MB)
테스트 18 〉	통과 (0.22ms, 90.5MB)
```

```java
효율성  테스트

테스트 1 〉	통과 (14.58ms, 55.6MB)
테스트 2 〉	통과 (13.33ms, 55.3MB)
```

```java
채점 결과

정확성: 69.5
효율성: 30.5
합계: 100.0 / 100.0
```