# 개념

## 스택의 ADT

- ADT라는 것은 추상 자료형이라는 뜻으로, 인터페이스만 있고 실제로 구현은 되어 있지 않은 자료형을 말한다.
- 문제를 보고 **이 문제를 스택으로 푸는게 좋겠다는 생각이 떠오르도록 하기 위해서는 스택의 세부 동작을 이해하고 있는 것이 좋다.**

### 스택의 세부 동작에 대해 더 자세히 알아보자.

- 스택의 PUSH
    1. isFull()을 수행해서 우선 data 배열에 데이터가 가득 찼는지를 검사한다.
    2. 그렇지 않으면 top을 1만큼 증가시킨다.
    3. top이 가리키는 위치에 값을 추가한다.
- 스택의 POP
    1. isEmpty()를 수행해서 data 배열에 데이터가 없는지 검사한다.
    2. top을 1만큼 감소시킨다
    - 값이 남아 있지 않나..라고 생각할 수 있지만, 사실상 top이 가리키는 것이 줄어들었기 때문에 stack이 비었다고 봐도 된다.

### 여기서 내가 궁금한게, 그럼 남은 3이라는 숫자를 가비지 컬렉션이 정리하나? 알아서?

- 이거는 사실상 객체가 무슨 타입인지에 따라 처리 방식이 다르다.

### 주요 처리 방식

#### 1. **그냥 방치 (가장 흔한 방식)**

```java
public int pop() {
    if (isEmpty()) throw new Exception();
    return data[top--];  // 값은 그대로 남아있음
}
```

- **배열의 값은 그대로 남아있다.**
- top만 감소시켜서 "논리적으로" 없는 것처럼 취급
- 다음 PUSH 시 자연스럽게 덮어씌워짐
- **가비지 컬렉션과 무관** - 배열은 여전히 그 값을 참조 중

#### 2. **명시적으로 null/0 초기화**

```java
public int pop() {
    if (isEmpty()) throw new Exception();
    int value = data[top];
    data[top] = null;  // 또는 0
    top--;
    return value;
}
```

- **객체 참조인 경우 중요** (예: `Stack<String>`)
- null로 설정해야 GC가 메모리 회수 가능
- 원시 타입(int 등)은 굳이 필요 없다.

### 결론

- **원시 타입**: 굳이 지울 필요 없음. 어차피 다음에 덮어씌워짐
- **객체 타입**: `null`로 초기화해야 GC가 메모리 회수 가능
- 남은 값 자체는 **자동으로 정리되지 않고**, 배열이 살아있는 한 메모리에 존재한다.