## 풀이

### 내 풀이

```java
import java.util.*;
import java.lang.*;

class Solution {
    public int[] solution(int[] prices) {
        // 이 방법이 아닌걸 아는데, 일단 이 방법으로 해보자..
        // 하나씩 비교하면서 늘리자.
        int[] answer = new int[prices.length];
        for(int i = 0; i<prices.length; i++){
            for(int j = i+1; j<prices.length; j++){
                answer[i]++;
                if(prices[i] > prices[j]){
                    break;
                }
            }
        }
        return answer;
    }
}
```

## 결과

```java
정확성  테스트

테스트 1 〉	통과 (0.01ms, 82.6MB)
테스트 2 〉	통과 (0.02ms, 70.8MB)
테스트 3 〉	통과 (0.15ms, 87.3MB)
테스트 4 〉	통과 (0.15ms, 84.3MB)
테스트 5 〉	통과 (0.20ms, 76.1MB)
테스트 6 〉	통과 (0.01ms, 77.6MB)
테스트 7 〉	통과 (0.09ms, 77.1MB)
테스트 8 〉	통과 (0.10ms, 90.4MB)
테스트 9 〉	통과 (0.02ms, 90.6MB)
테스트 10 〉	통과 (0.18ms, 86.6MB)

효율성  테스트

테스트 1 〉	통과 (18.01ms, 74.5MB)
테스트 2 〉	통과 (10.20ms, 66.3MB)
테스트 3 〉	통과 (29.82ms, 73MB)
테스트 4 〉	통과 (16.83ms, 71.8MB)
테스트 5 〉	통과 (11.72ms, 67MB)
```

## 참고 개념

이 문제에서 중요한 부분은, 불 필요한 계산을 Stack을 이용해서 없애는 것이다!

이 문제의 키 포인트는 이것이다. 줄어든 부분 이후에 대해서는 계산하지 않는 것이다.

즉, 뒤에서 앞으로 가면서 작은 부분의 수는 확정짓고 가는게 바로 불필요한 계산을 없애는 방법인 것이다!!!!

이를 먼저 대략적인 아이디어 정리 방향으로 정리하면 다음과 같다.

## 1차 풀이

```java

class Solution {
    public int[] solution(int[] prices) {
        int[] answer = new int[prices.length];
        // 1. 스택 정의
        Deque<Integer> stack = new ArrayDeque<Integer>();
        
        stack.push(0); // 초기 인덱스 올리기
        
        int ind = 1;
        
        // 2. top (이전 가격) & push (이후 가격) 비교
        while(!stack.isEmpty() && ind < answer.length-1){
            if(prices[stack.peek()] > prices[ind]){
                int indx = stack.pop();
                answer[indx] = ind-indx;
            }else{
                stack.push(ind++);
            }
        }

        // 3. 비우기
        while(!stack.isEmpty()){
            int indx = stack.pop();
            answer[indx] = ind-indx;
        }
        
        return answer;
    }
}
```

처음에 이렇게 풀어서 틀렸는데, 이유는

🌟 !stack.isEmpty() && ind < answer.length-1 이렇게 while 조건을 둘 경우, 너무 일찍 끝날 수 있기 때문이다!!!

당연히 배열 끝까지는 전부 push를 해야 하는거고, 대신 비어있거나 && 계속 해야 할때는 올리는 방식으로 가면 일관된 로직으로 구할 수 있다.

## 고친 풀이

### 1차 풀이

```java
import java.util.*;
import java.lang.*;
class Solution {
    public int[] solution(int[] prices) {
        int[] answer = new int[prices.length];
        // 1. 스택 정의
        Deque<Integer> stack = new ArrayDeque<Integer>();

        stack.push(0); // 초기 인덱스 올리기

        int ind = 1;

        // 2. top (이전 가격) & push (이후 가격) 비교
        while(ind < answer.length-1){
            if(stack.isEmpty() || prices[stack.peek()] <= prices[ind]){
                stack.push(ind++);
            }else{
                int indx = stack.pop();
                answer[indx] = ind-indx;
            }
        }
        // 3. 비우기
        while(!stack.isEmpty()){
            int indx = stack.pop();
            answer[indx] = ind-indx;
        }

        return answer;
    }
}
```

```java
정확성  테스트

테스트 1 〉	통과 (0.05ms, 80.2MB)
테스트 2 〉	통과 (0.21ms, 85.1MB)
테스트 3 〉	통과 (1.37ms, 88.2MB)
테스트 4 〉	통과 (1.20ms, 83.4MB)
테스트 5 〉	통과 (1.09ms, 78.9MB)
테스트 6 〉	통과 (0.16ms, 89.2MB)
테스트 7 〉	통과 (0.89ms, 91.6MB)
테스트 8 〉	통과 (0.73ms, 92.6MB)
테스트 9 〉	통과 (0.13ms, 73MB)
테스트 10 〉	통과 (0.98ms, 77.8MB)

효율성  테스트

테스트 1 〉	통과 (26.14ms, 75.9MB)
테스트 2 〉	통과 (24.37ms, 70.1MB)
테스트 3 〉	통과 (30.13ms, 92.5MB)
테스트 4 〉	통과 (24.23ms, 73.1MB)
테스트 5 〉	통과 (21.95ms, 69.9MB)

채점 결과

정확성: 66.7
효율성: 33.3
합계: 100.0 / 100.0
```

### 1차 회고

일단 뭐 맞기야 하고 아이디어 자체는 맞지만,

시작점을 정의해두고 가격이 떨어진 지점에서 백으로 계산하는 방식과 다르게

유지보수와 가독성 측면에서 좋지 않은 풀이라고 한다!!

아… for, while을 조금 덜 쓴다고 해서 다 좋은 풀이가 아니라는걸 알았다.

효율성 뿐 아니라 한 눈에 들어오도록 **유지보수, 가독성**을 더 신경써야겠다는 생각을 했다…

### 2차 풀이 (최종)

```sql
import java.util.*;
import java.lang.*;

class Solution {
    public int[] solution(int[] prices) {
        int[] answer = new int[prices.length];
        // 1. 스택 정의
        Deque<Integer> stack = new ArrayDeque<Integer>();
        
        stack.push(0); // 초기 인덱스 올리기
        int ind;
        
        // 2. top (이전 가격) & push (이후 가격) 비교
        for(ind = 1; ind < answer.length; ind++){ //시작점
            while(!stack.isEmpty() && prices[stack.peek()] > prices[ind]){
                int indx = stack.pop();
                answer[indx] = ind-indx;
            }
            stack.push(ind);
        }

        // 3. 비우기
        while(!stack.isEmpty()){
            int indx = stack.pop();
            answer[indx] = ind-indx-1;
        }
        
        return answer;
    }
}
```

```sql
정확성  테스트

테스트 1 〉	통과 (0.07ms, 79.7MB)
테스트 2 〉	통과 (0.33ms, 81MB)
테스트 3 〉	통과 (0.97ms, 89.8MB)
테스트 4 〉	통과 (1.16ms, 93.8MB)
테스트 5 〉	통과 (0.84ms, 81.9MB)
테스트 6 〉	통과 (0.18ms, 74.1MB)
테스트 7 〉	통과 (0.59ms, 76.3MB)
테스트 8 〉	통과 (0.93ms, 74.7MB)
테스트 9 〉	통과 (0.18ms, 87.6MB)
테스트 10 〉	통과 (0.99ms, 86.5MB)

효율성  테스트

테스트 1 〉	통과 (28.10ms, 72.1MB)
테스트 2 〉	통과 (20.80ms, 67.5MB)
테스트 3 〉	통과 (28.46ms, 73.5MB)
테스트 4 〉	통과 (24.21ms, 68.9MB)
테스트 5 〉	통과 (21.51ms, 68MB)

채점 결과

정확성: 66.7
효율성: 33.3
합계: 100.0 / 100.0
```