## 풀이

### 내 풀이

```java
import java.lang.*;

class Solution {
    public int solution(String dirs) {
        int answer = 0;
        char[] dir = dirs.toCharArray();
        boolean[][] stage = new boolean[11][11];
        
        int x = 5;
        int y = 5;
        
        // 지나간 거리를 표기한다.
        // O(N)
        for(char di : dir){
            if(di == 'L'){
                if(isTrue(-1, 0, x, y)){
                    stage[y][x--] = true;
                }
                // 넘어가는 명령은 무시한다.
            }else if(di == 'R'){
                if(isTrue(1, 0, x, y)){
                    stage[y][x++] = true;
                }
            }else if(di == 'U'){
                if(isTrue(0, -1, x, y)){
                    stage[y--][x] = true;
                }
            }else{
                if(isTrue(0, 1, x, y)){
                    stage[y++][x] = true;
                }
            }
            // 이렇게 하면, 다른 방향에서 오는 끝 점이 겹칠 경우를 구할 수 없다.
            stage[y][x] = true; 
        }
        
        // 표식을 이용해서 최종 거리를 구한다.
        // O(N^2)
        for(int i = 0; i<=10; i++){
            for(int j = 0; j<=10; j++){
                if(stage[i][j]){
                    answer++;
                }
            }
        }
        return answer-1;
    }
    
    public boolean isTrue(int plusX, int plusY, int x, int y){
        if(x + plusX >= 0 && x + plusX <= 10 && y + plusY >= 0 && y + plusY <= 10){
            return true;
        }
        return false;
    }
}
```

- 푼 것
    - 시작점과 끝 점 각각을 전부 true로 표시한다.
    - 이렇게 할 경우,. 1번 예시처럼 끝점은 같은데 다른 방향에서 오는 것을 계산할 수 없다.
    - 뭔가 움직임을 계산하는걸 배열로 한게 실수인가 아니면 방식이 따로 있나 싶긴한데 모르겠다….

### 참고 어드바이스

- 이건 아이디어를 못 찾겠어서 풀이의 힘을 빌렸다.
- 이 문제의 핵심은 이것이다.
    - 중복 경로는 최종 길이에 포함하지 않는다.
    - 즉, 중복을 포함하지 않는다는 문장이 나오면 **HashSet<>();**을 떠올리는 것이 좋다.
    - 이 문제의 포인트는, a → b를 방문한다는 것 자체를 **HashSet<>();에 저장해서, 그 사이즈로 /2 해서 값을 중복을 제거한 값을 구하는 것이다!!! (방향성이 없으므로 두 번 저장해서 /2 해야 한다.)**
        - 시작점과 끝점만 저장해서는, 여러 방향에서 오는 “길”들을 전부 저장하는게 불가능이다.
- 또한, 다른 알고리즘 문제도 마찬가지지만 구현 문제는 답의 코드가 길기 때문에 method로 분리하는 것이 좋다.

### 참고 후 풀이

```java
import java.lang.*;
import java.util.*;

class Solution {
    // 방향을 저장하기 위한 map
    private static final HashMap<Character, int[]> location = new HashMap<Character, int[]>();
    //location을 저장한 HashMap을 init 하기 위함.
    public static void initLocation(){
        location.put('U', new int[]{0,1});
        location.put('D', new int[]{0,-1});
        location.put('L', new int[]{-1,0});
        location.put('R', new int[]{1,0});
    }
    
    public int solution(String dirs) {
        initLocation(); //초기화
        HashSet<String> answer = new HashSet<>(); // 이동 좌표를 저장하기 위한 set
        
        int x = 5;
        int y = 5;
        
        for(int i = 0; i<dirs.length(); i++){
            int dirX = x + location.get(dirs.charAt(i))[0];
            int dirY = y + location.get(dirs.charAt(i))[1];
            
            if(!isTrue(dirX, dirY)){
                continue; // 넘을 경우 무시
            }
            
            answer.add(x + ">" + dirX + ", " + y + ">" + dirY);
            answer.add(dirX + ">" + x + ", " + dirY + ">" + y); //방향성이 없으므로 반대도 넣어준다.
            
            x = dirX;
            y = dirY;
        }
        
        return (answer.size())/2;
    }
    
    public boolean isTrue(int x, int y){
        if(x >= 0 && x <= 10 && y >= 0 && y <= 10){
            return true;
        }
        return false;
    }
}
```

```java
테스트 1 〉	통과 (37.68ms, 86.8MB)
테스트 2 〉	통과 (16.90ms, 91.9MB)
테스트 3 〉	통과 (20.93ms, 79.7MB)
테스트 4 〉	통과 (21.36ms, 82.9MB)
테스트 5 〉	통과 (16.17ms, 88.4MB)
테스트 6 〉	통과 (12.53ms, 74.1MB)
테스트 7 〉	통과 (21.47ms, 81.5MB)
테스트 8 〉	통과 (18.53ms, 86.5MB)
테스트 9 〉	통과 (19.79ms, 79.6MB)
테스트 10 〉	통과 (21.84ms, 77MB)
테스트 11 〉	통과 (37.17ms, 81.4MB)
테스트 12 〉	통과 (14.41ms, 79.1MB)
테스트 13 〉	통과 (24.57ms, 87.4MB)
테스트 14 〉	통과 (24.13ms, 95.1MB)
테스트 15 〉	통과 (18.23ms, 86.2MB)
테스트 16 〉	통과 (17.96ms, 92.2MB)
테스트 17 〉	통과 (23.86ms, 78.6MB)
테스트 18 〉	통과 (30.27ms, 80.1MB)
테스트 19 〉	통과 (18.50ms, 73.8MB)
테스트 20 〉	통과 (28.58ms, 80.1MB)
```

### 만약, StringBuilder를 사용한다면?

```java
import java.lang.*;
import java.util.*;

class Solution {
    // 방향을 저장하기 위한 map
    private static final HashMap<Character, int[]> location = new HashMap<Character, int[]>();
    //location을 저장한 HashMap을 init 하기 위함.
    public static void initLocation(){
        location.put('U', new int[]{0,1});
        location.put('D', new int[]{0,-1});
        location.put('L', new int[]{-1,0});
        location.put('R', new int[]{1,0});
    }
    
    public int solution(String dirs) {
        initLocation(); //초기화
        StringBuilder stb = new StringBuilder();
        HashSet<String> answer = new HashSet<>(); // 이동 좌표를 저장하기 위한 set
        
        int x = 5;
        int y = 5;
        
        for(int i = 0; i<dirs.length(); i++){
            int dirX = x + location.get(dirs.charAt(i))[0];
            int dirY = y + location.get(dirs.charAt(i))[1];
            
            if(!isTrue(dirX, dirY)){
                continue; // 넘을 경우 무시
            }
            stb.append(x).append(">").append(dirX).append(", ")
                .append(y).append(">").append(dirY);
            answer.add(new String(stb));
            stb.setLength(0); //비우기
            
            stb.append(dirX).append(">").append(x).append(", ")
                .append(dirY).append(">").append(y);
            answer.add(new String(stb)); //방향성이 없으므로 반대도 넣어준다.
            stb.setLength(0); //비우기
            
            x = dirX;
            y = dirY;
        }
        
        return (answer.size())/2;
    }
    
    public boolean isTrue(int x, int y){
        if(x >= 0 && x <= 10 && y >= 0 && y <= 10){
            return true;
        }
        return false;
    }
}
```

```java
테스트 1 〉	통과 (0.55ms, 72.8MB)
테스트 2 〉	통과 (0.26ms, 87MB)
테스트 3 〉	통과 (0.26ms, 86.1MB)
테스트 4 〉	통과 (0.72ms, 70.1MB)
테스트 5 〉	통과 (1.35ms, 72.6MB)
테스트 6 〉	통과 (1.08ms, 90.9MB)
테스트 7 〉	통과 (0.28ms, 86.2MB)
테스트 8 〉	통과 (0.63ms, 73.1MB)
테스트 9 〉	통과 (0.59ms, 72.3MB)
테스트 10 〉	통과 (0.60ms, 73.3MB)
테스트 11 〉	통과 (0.58ms, 87.2MB)
테스트 12 〉	통과 (0.78ms, 78.5MB)
테스트 13 〉	통과 (0.89ms, 71.3MB)
테스트 14 〉	통과 (1.04ms, 73.7MB)
테스트 15 〉	통과 (0.90ms, 72.7MB)
테스트 16 〉	통과 (2.23ms, 90.6MB)
테스트 17 〉	통과 (2.31ms, 74.5MB)
테스트 18 〉	통과 (2.59ms, 87.8MB)
테스트 19 〉	통과 (1.98ms, 84.4MB)
테스트 20 〉	통과 (2.57ms, 70.9MB)
```

## 😯 [문법] Builder vs Concat에서 이러한 차이가 나는 이유는 무엇일까?

> String concatenation: **평균 ~21ms**
> StringBuilder: **평균 ~1ms**

**약 20배 이상 빠르다!!!**

## 왜 이렇게 차이가 날까?

```java
*// String concatenation (느림)*
answer.add(x + ">" + dirX + ", " + y + ">" + dirY);
```

이 한 줄이 내부적으로는:

```java
// 실제로는 이렇게 동작
String temp1 = String.valueOf(x);
String temp2 = temp1 + ">";
String temp3 = temp2 + String.valueOf(dirX);
String temp4 = temp3 + ", ";
String temp5 = temp4 + String.valueOf(y);
String temp6 = temp5 + ">";
String temp7 = temp6 + String.valueOf(dirY);
// 매번 새로운 String 객체 생성!
```

**반복문 안에서는 이 차이가 극적으로 커지는데, 이게 지금 단일 반복문 안에 있기 때문에 차이가 나는 것이다!**

```java
// StringBuilder (빠름)
stb.setLength(0);
stb.append(x).append(">").append(dirX).append(", ").append(y).append(">").append(dirY);
answer.add(stb.toString());
// 하나의 버퍼에서 작업 후 마지막에만 String 생성*
```

## 교훈

- **반복문 안에서 문자열 연결** → StringBuilder 필수!
- **한 번만 연결** → String `+` 사용해도 OK
- 코딩 테스트에서는 이런 최적화가 **통과/시간초과**를 가를 수 있다!!
- 사실 여기는 반복문도 하나고..통과하는데는 큰 무리 없다만, 더 좋은 방법이 있는 것이므로 알아두도록 하자.