## 문제

슈퍼 게임 개발자 오렐리는 큰 고민에 빠졌다. 그녀가 만든 프랜즈 오천성이 대성공을 거뒀지만, 요즘 신규 사용자의 수가 급감한 것이다. 원인은 신규 사용자와 기존 사용자 사이에 스테이지 차이가 너무 큰 것이 문제였다.

이 문제를 어떻게 할까 고민 한 그녀는 동적으로 게임 시간을 늘려서 난이도를 조절하기로 했다. 역시 슈퍼 개발자라 대부분의 로직은 쉽게 구현했지만, 실패율을 구하는 부분에서 위기에 빠지고 말았다. 오렐리를 위해 실패율을 구하는 코드를 완성하라.

- 실패율은 다음과 같이 정의한다.
    - 스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수 / 스테이지에 도달한 플레이어 수

전체 스테이지의 개수 N, 게임을 이용하는 사용자가 현재 멈춰있는 스테이지의 번호가 담긴 배열 stages가 매개변수로 주어질 때, 실패율이 높은 스테이지부터 내림차순으로 스테이지의 번호가 담겨있는 배열을 return 하도록 solution 함수를 완성하라.

### 제한사항

- 스테이지의 개수 N은 `1` 이상 `500` 이하의 자연수이다.
- stages의 길이는 `1` 이상 `200,000` 이하이다.
- stages에는 `1` 이상 `N + 1` 이하의 자연수가 담겨있다.
    - 각 자연수는 사용자가 현재 도전 중인 스테이지의 번호를 나타낸다.
    - 단, `N + 1` 은 마지막 스테이지(N 번째 스테이지) 까지 클리어 한 사용자를 나타낸다.
- 만약 실패율이 같은 스테이지가 있다면 작은 번호의 스테이지가 먼저 오도록 하면 된다.
- 스테이지에 도달한 유저가 없는 경우 해당 스테이지의 실패율은 `0` 으로 정의한다.

### 제한 사항

- 행렬 arr1, arr2의 행과 열의 길이는 2 이상 100 이하입니다.
- 행렬 arr1, arr2의 원소는 -10 이상 20 이하인 자연수입니다.
- 곱할 수 있는 배열만 주어집니다.

### 입출력 예시

| N | stages | result |
| --- | --- | --- |
| 5 | [2, 1, 2, 6, 2, 4, 3, 3] | [3,4,2,1,5] |
| 4 | [4,4,4,4,4] | [4,1,2,3] |

## 풀이

### 내 풀이

```java
import java.util.*;
import java.lang.*;

class Solution {
    public int[] solution(int N, int[] stages) {
        int[] answer = {};
        Map<Integer, Float> map = new HashMap<Integer, Float>();
        
        for(int ind = 1; ind <= N; ind++){
            float a = 0;
            float b = 0;
            for(int n : stages){
                if(ind == n){ //도달했으나 클리어 못함
                    a++;
                }else if(ind < n){
                    b++;
                }
            }
            if(a == 0 && b == 0){ //도달한 사람이 아예 없음
                map.put(ind,(float) 0);
            }else{
                map.put(ind,a/(a+b));
            }
        }
        
        // Q. map을 array Sorted로 할 수 있나?
        // 이거 stream 문법 외워야 한다. 다음에 꼭 다시 한 번 복습하기...
        answer = map.entrySet().stream()
            .sorted(Map.Entry.<Integer, Float>comparingByValue().reversed())
            .mapToInt(Map.Entry::getKey)
            .toArray();
        
        return answer;
    }
}
```

- ide 없이 풀려니까 이 쉬운 문제가 어렵네…
- map으로 잡고 sorted 했는데
    1. map.entrySet().stream() : map을 stream()으로 바꿔서 데이터 흐름대로 할 수 있도록 한다.
    2. .sorted(comparingByValue().reversed()) : sorted를 이용해서 value를 기준으로 reversed로 정렬한다.
    3. .mapToInt(Map.Entry::getKey) : 정렬된 결과에서 key만 뽑아서 배열로 설정
    4. .toArray() : 배열로 바꿔라

```java
if(a == 0 && b == 0){ //도달한 사람이 아예 없음
    map.put(ind,(float) 0);
}else{
    map.put(ind,a/b);
}
```

- 0/0은 infinity 이므로, 이 제약조건이 있어야 한다.
- 문제 좀 꼼꼼히 읽어라!!!!

> 근데 내 풀이의 경우 문제가 있다. N = 500, stages가 200,000이하 이므로, for 중첩문으로 최대 1억번의 연산이 들어간다.

그러므로, 참고 풀이를 보고 내 풀이의 비효율적인 부분을 고쳐보자.


```java
테스트 1 〉	통과 (6.00ms, 76.7MB)
테스트 2 〉	통과 (3.77ms, 90.4MB)
테스트 3 〉	통과 (31.14ms, 78.7MB)
테스트 4 〉	통과 (120.00ms, 99MB)
테스트 5 〉	통과 (428.20ms, 95.3MB)
테스트 6 〉	통과 (6.93ms, 72.6MB)
테스트 7 〉	통과 (19.75ms, 91.8MB)
테스트 8 〉	통과 (114.99ms, 84.8MB)
테스트 9 〉	통과 (500.52ms, 91.8MB)
테스트 10 〉	통과 (67.37ms, 95.8MB)
테스트 11 〉	통과 (121.01ms, 82.2MB)
테스트 12 〉	통과 (81.79ms, 106MB)
테스트 13 〉	통과 (128.54ms, 104MB)
테스트 14 〉	통과 (4.98ms, 87.3MB)
테스트 15 〉	통과 (12.90ms, 91.8MB)
테스트 16 〉	통과 (10.27ms, 93.4MB)
테스트 17 〉	통과 (19.25ms, 89.8MB)
테스트 18 〉	통과 (8.69ms, 76.7MB)
테스트 19 〉	통과 (8.25ms, 93.2MB)
테스트 20 〉	통과 (11.71ms, 74.9MB)
테스트 21 〉	통과 (13.92ms, 93.7MB)
테스트 22 〉	통과 (270.97ms, 91.8MB)
테스트 23 〉	통과 (16.54ms, 84.9MB)
테스트 24 〉	통과 (37.46ms, 86.7MB)
테스트 25 〉	통과 (3.74ms, 84.5MB)
테스트 26 〉	통과 (7.49ms, 88.3MB)
테스트 27 〉	통과 (7.50ms, 90.1MB)
```

### 발전 풀이

```java
int[] challenges = new int[N+2]; //도달한 사람 수, N+1까지 가능하므로 N+2로 설정

for(int num : stages){
    challenges[num]++;
}

float total = stages.length;
for(int ind = 1; ind <= N; ind++){
    float a = challenges[ind]; //도달했는데 못깬

    if(total == 0){ //도달한 사람이 아예 없음
        map.put(ind,0.0f);
    }else{
        map.put(ind,a/total);
        total -= challenges[ind]; //다음 계산을 위해 제거
    }
}
```

지금 내 풀이에서 효율성이 떨어지는 부분은 for 중첩이다.

이 문제의 경우, N이 500까지이고, stages의 길이가 200,000까지 가므로 중첩 풀이는 1억 번의 계산이 일어난다. 그러므로 for문 중첩을 제거할 수 있다면 제거하는게 맞음

> 이 문제의 포인트는 그거다.
>
> 스테이지에 도달한 사람은 사실상 스테이지에 도달했지만 못 깬 사람의 수만 알면 구할 수 있으니까
> 스테이지에 도달했지만 못한 사람을 구하기 위해 n+2 배열을 두고
> 전체에서 그걸 계속 제거하는 방식으로 현재 스테이지에 도달한 사람 수를 구한다.
>

### 최종 풀이

```java
import java.util.*;
import java.lang.*;

class Solution {
    public int[] solution(int N, int[] stages) {
        int[] answer = {};
        Map<Integer, Float> map = new HashMap<Integer, Float>();
        int[] challenges = new int[N+2]; //도달한 사람 수, N+1까지 가능하므로 N+2로 설정
        
        for(int num : stages){
            challenges[num]++;
        }
        
        float total = stages.length;
        for(int ind = 1; ind <= N; ind++){
            float a = challenges[ind]; //도달했는데 못깬
            
            if(total == 0){ //도달한 사람이 아예 없음
                map.put(ind,0.0f);
            }else{
                map.put(ind,a/total);
                total -= challenges[ind]; //다음 계산을 위해 제거
            }
        }
        
        answer = map.entrySet().stream()
            .sorted(Map.Entry.<Integer, Float>comparingByValue().reversed())
            .mapToInt(Map.Entry::getKey)
            .toArray();
        
        return answer;
    }
}
```

```java
테스트 1 〉	통과 (3.98ms, 94.2MB)
테스트 2 〉	통과 (4.54ms, 74.8MB)
테스트 3 〉	통과 (9.29ms, 93.8MB)
테스트 4 〉	통과 (8.83ms, 84.9MB)
테스트 5 〉	통과 (9.59ms, 103MB)
테스트 6 〉	통과 (6.31ms, 86.9MB)
테스트 7 〉	통과 (6.87ms, 75.9MB)
테스트 8 〉	통과 (8.20ms, 81.2MB)
테스트 9 〉	통과 (12.25ms, 85MB)
테스트 10 〉	통과 (7.62ms, 95.1MB)
테스트 11 〉	통과 (9.68ms, 98.1MB)
테스트 12 〉	통과 (15.55ms, 95.3MB)
테스트 13 〉	통과 (9.23ms, 84.6MB)
테스트 14 〉	통과 (5.24ms, 71.8MB)
테스트 15 〉	통과 (5.76ms, 91.1MB)
테스트 16 〉	통과 (4.65ms, 87.3MB)
테스트 17 〉	통과 (6.07ms, 78.7MB)
테스트 18 〉	통과 (4.63ms, 73.7MB)
테스트 19 〉	통과 (6.00ms, 80.2MB)
테스트 20 〉	통과 (4.65ms, 93.4MB)
테스트 21 〉	통과 (5.63ms, 76MB)
테스트 22 〉	통과 (8.35ms, 97.2MB)
테스트 23 〉	통과 (8.86ms, 99.2MB)
테스트 24 〉	통과 (9.73ms, 102MB)
테스트 25 〉	통과 (5.03ms, 89.3MB)
테스트 26 〉	통과 (4.62ms, 76.8MB)
테스트 27 〉	통과 (3.43ms, 73.7MB)
```

### 🫵🏻 알고리즘 성능 비교: 이중 for문 vs 배열 카운팅

#### 성능 비교 결과

#### 최악의 케이스들

| 테스트 케이스 | 이중 for문 | 배열 카운팅 | 개선율 |
| --- | --- | --- | --- |
| 테스트 5 | 428.20ms | 9.59ms | **44.6배 빠름** ⚡ |
| 테스트 9 | 500.52ms | 12.25ms | **40.9배 빠름** ⚡ |
| 테스트 22 | 270.97ms | 8.35ms | **32.4배 빠름** ⚡ |
| 테스트 4 | 120.00ms | 8.83ms | **13.6배 빠름** |
| 테스트 13 | 128.54ms | 9.23ms | **13.9배 빠름** |

#### 평균 성능

- **이중 for문 평균**: 약 73.5ms
- **배열 카운팅 평균**: 약 7.5ms
- **결과**: 평균 약 **10배 빠름** 🚀

---

### 시간 복잡도 분석

#### 이중 for문 방식: O(N × stages.length)

```java
for(int ind = 1; ind <= N; ind++){          // N번
    for(int n : stages){                     // stages.length번
        if(ind == n) a++;
        else if(ind < n) b++;
    }
}
```

**테스트 5번 추정 케이스:**

- N = 500 (스테이지 개수)
- stages.length = 200,000 (사용자 수)
- **연산 횟수: 500 × 200,000 = 1억 번** 😱

---

#### 배열 카운팅 방식: O(N + stages.length)

```java
// 1단계: 각 스테이지별 카운팅 O(stages.length)
int[] challenges = new int[N+2];
for(int num : stages){
    challenges[num]++;
}

// 2단계: 실패율 계산 O(N)
float total = stages.length;
for(int ind = 1; ind <= N; ind++){
    float a = challenges[ind];

    if(total == 0){
        map.put(ind, 0.0f);
    } else {
        map.put(ind, a/total);
        total -= a;
    }
}
```

**같은 케이스:**

- N = 500
- stages.length = 200,000
- **연산 횟수: 500 + 200,000 = 200,500번** ✅
- **약 500배 적은 연산!**

---

### 교훈

✅ **시간복잡도는 이론이 아니라 현실**

- O(N²) vs O(N): 실제로 40배 이상 차이 발생
- 효율성 테스트가 있었다면 시간초과 확정

✅ **"통과했으니 OK"는 위험한 생각**

- 레벨 3~4 문제에서는 이런 접근으로 바로 탈락
- **항상 최적화된 풀이 습관 들이기**

✅ **공간을 활용해 시간을 줄인다**

- 추가 배열 N+2개 사용 → 연산 500배 감소
- 메모리는 충분하니 시간복잡도 우선!