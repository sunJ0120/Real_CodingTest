## 풀이

### 첫 풀이
```java
import java.lang.*;
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        int[] answer = {};
        List<Integer> list = new ArrayList<Integer>();
        Deque<Integer> que = new ArrayDeque<Integer>();
        // 1. 100-n/speed 계산해서 que에 addLast로 올린다.
        for(int i = 0; i<progresses.length; i++){
            int progresse = (int) Math.ceil((double)(100-progresses[i])/(double) speeds[i]);
            que.addLast(progresse);
        }
        // 2. 처음 수를 pollFirst로 꺼내서, 작거나 같을때까지 반복한다.
        while(!que.isEmpty()){
            int top = que.pollFirst();
            int cnt = 1;
            while(!que.isEmpty() && que.peekFirst() <= top){
                que.pollFirst();
                cnt++;
            }
            list.add(cnt);
        }
        // 3. 배열을 출력한다. (동적 배열을 변환하는 과정이 필요), 문법 외우기
        answer = list.stream()
                .mapToInt(Integer::intValue)
                .toArray();

        return answer;
    }
}
```
- stream()으로 배열 변환하는 법 외워야 한다.
- (double)로 명시적 업캐스팅 필요하고, (int) 로 다운캐스팅 해야 한다.

#### 정확성 테스트
```java
테스트 1 〉	통과 (5.27ms, 77.5MB)
테스트 2 〉	통과 (3.37ms, 68.5MB)
테스트 3 〉	통과 (3.10ms, 91.4MB)
테스트 4 〉	통과 (5.86ms, 73.2MB)
테스트 5 〉	통과 (2.47ms, 73.1MB)
테스트 6 〉	통과 (3.23ms, 73MB)
테스트 7 〉	통과 (2.71ms, 89.8MB)
테스트 8 〉	통과 (2.94ms, 76MB)
테스트 9 〉	통과 (2.97ms, 72.8MB)
테스트 10 〉	통과 (2.44ms, 70.6MB)
테스트 11 〉	통과 (3.05ms, 77.9MB)
```

### 참고 후 리팩터링
```java
import java.lang.*;
import java.util.*;

class Solution {
    public int[] solution(int[] progresses, int[] speeds) {
        int[] answer = {};
        int[] days = new int[progresses.length];
        Deque<Integer> que = new ArrayDeque<Integer>();
        
        // 1. 100-n/speed 계산해서 que에 addLast로 올린다.
        for(int i = 0; i<progresses.length; i++){
            int progresse = (int) Math.ceil((double)(100-progresses[i])/(double) speeds[i]);
            days[i] = progresse;
        }
        // 2. maxLate로 해당 분기에서 가장 오래 걸리는 작업을 꺼낸다.
        int maxLate = days[0];
        int cnt = 1;
        for(int i = 1; i<progresses.length; i++){
            if(days[i] <= maxLate){
                cnt++;
            }else{
                maxLate = days[i];
                // 순서대로 출력하기 위해 que에 올린다.
                que.addLast(cnt);
                cnt = 1;
            }
        }
        que.addLast(cnt);    // 배열 반복상 포함되지 않는 마지막 작업을 같이 올린다.
        // 3. 배열을 출력한다. (동적 배열을 변환하는 과정이 필요), 문법 외우기
        answer = que.stream()
            .mapToInt(Integer::intValue)
            .toArray();
        
        return answer;
    }
}
```
#### 정확성 테스트
```java
정확성  테스트
테스트 1 〉	통과 (2.69ms, 81.5MB)
테스트 2 〉	통과 (2.25ms, 75.3MB)
테스트 3 〉	통과 (3.04ms, 81.1MB)
테스트 4 〉	통과 (3.16ms, 81MB)
테스트 5 〉	통과 (2.09ms, 86.1MB)
테스트 6 〉	통과 (2.16ms, 99.4MB)
테스트 7 〉	통과 (2.25ms, 73.1MB)
테스트 8 〉	통과 (2.12ms, 90.1MB)
테스트 9 〉	통과 (2.25ms, 79.4MB)
테스트 10 〉	통과 (2.67ms, 73.9MB)
테스트 11 〉	통과 (2.53ms, 87.2MB)
```
- 앞에 있는 수가 가장 오래 걸리는 작업! 이라는걸 이해해야 한다.
- 이를 통해 불편한 while문 두 겹을 한 겹의 for문으로 바꿀 수 있다.
- mapToInt 사용법이나..로직 관련 복습 필수