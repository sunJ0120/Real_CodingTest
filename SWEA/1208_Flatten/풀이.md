## 풀이
```java
import java.io.*;
import java.lang.*;
import java.util.*;

/*
   사용하는 클래스명이 Solution 이어야 하므로, 가급적 Solution.java 를 사용할 것을 권장합니다.
   이러한 상황에서도 동일하게 java Solution 명령으로 프로그램을 수행해볼 수 있습니다.
 */
class Solution
{
	public static void main(String args[]) throws Exception
	{
		/*
		   표준입력 System.in 으로부터 스캐너를 만들어 데이터를 읽어옵니다.
		 */
		Scanner sc = new Scanner(System.in);
		int T;
		//T=sc.nextInt();
        T=10;
		/*
		   여러 개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
		*/
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		for(int test_case = 1; test_case <= T; test_case++)
		{
		
			/////////////////////////////////////////////////////////////////////////////////////////////
            int num = sc.nextInt();
            int[] height = new int[100];
            for(int i = 0; i<100; i++){
                height[i] = sc.nextInt();
            }

            // 2. 정렬한다.
            Arrays.sort(height);

            // 1. 덤프횟수 
            for(int i = 0; i<num; i++){
                height[99]--;
                height[0]++;

                // 덤프 후에는 최대 최소가 아닐 수 있으므로 재정렬한다.
                Arrays.sort(height);
 
                // 3. 최대 최소 차이 1이면 바로 끝
                if(height[99] - height[0] <= 1){
                    break;
                }
            }
            int minus = height[99] - height[0];
            bw.write("#" + test_case + " " + minus + "\n");
			/////////////////////////////////////////////////////////////////////////////////////////////
		}
        bw.flush();
        bw.close();
	}
}
```
- 처음에는 이렇게 해서 틀렸었음
```java
// 1. 덤프횟수 
for(int i = 0; i<num; i++){
    Arrays.sort(height);
        
    height[99]--;
    height[0]++;

    // 3. 최대 최소 차이 1이면 바로 끝
    if(height[99] - height[0] <= 1){
        break;
    }
}
```
- 그러나 최대 최소의 차이가 포인트인데, 덤프 후에 최대 최소라는 보장이 없으므로, 
- 우선 한 번의 덤프 (for 문 규칙에 따라 앞에서 시행)가 끝난 후에는 sort를 해서 최대 최소 구해야함
  - 문제 요구사항을 잘 읽자!!

> 사실 이렇게 계속 정렬하는데 올바른 풀이는 아니다....누가봐도 비 효율적인 풀인데 SWEA는 풀이 시간이 굉장히 넉넉한 편이라 일단 최대한 직관적으로 풀었음

