## 풀이
```java
import java.io.*;
import java.util.Scanner;

class Solution
{
    public static int isPalindRow(char[][] palindromes, int start, int len, int row){
        int end = start + len - 1;
        while(start <= end){
            if (palindromes[row][start] != palindromes[row][end]) {
                return 0;
            }
            start++;
            end--;
        }
        return 1;
    }

    public static int isPalindCol(char[][] palindromes, int start, int len, int col){
        int end = start + len - 1;
        while(start <= end){
            if (palindromes[start][col] != palindromes[end][col]) {
                return 0;
            }
            start++;
            end--;
        }
        return 1;
    }

    public static void main(String args[]) throws Exception
    {
        Scanner sc = new Scanner(System.in);
        int T;
        //T=sc.nextInt();
        T=10;
		/*
		   여러 개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
		*/
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        for(int test_case = 1; test_case <= T; test_case++)
        {
            /////////////////////////////////////////////////////////////////////////////////////////////
            int len = sc.nextInt();    // 팰린드롬 길이
            char[][] palindromes = new char[8][8];
            int answer = 0;

            for (int i = 0; i<8; i++) {
                palindromes[i] = sc.next().toCharArray();
            }

            for(int i = 0; i<8; i++){
                for(int j = 0; j<=8-len; j++){  //row에 해당
                    // System.out.println("start : " + j);
                    answer += isPalindRow(palindromes, j, len, i);
                    answer += isPalindCol(palindromes, j, len, i);
                }
            }
            bw.write("#" + test_case + " " + answer + "\n");
            /////////////////////////////////////////////////////////////////////////////////////////////
        }
        bw.flush();
        bw.close();
    }
}
```
- 이 문제의 경우는 유명한 펠린드롬 문제이다.
- 펠린드롬 문제는 아무래도..이렇게 method를 따로 분리하는게 참 편했던 기억이 있어서 분리해서 만들었다.
- 사실 row, col 이 두개 로직 유사한데 분리해둔게 좀 거슬리긴 한다만...음 최적화 할 방향이 있다면 생각해봐야겠다.

