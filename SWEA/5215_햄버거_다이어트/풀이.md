## 풀이
```java
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.util.Scanner;

class Solution
{
    public static int limit;
    public static int maxScore;

    public static void dfs(int[][] cal, int start, int kcal, int score, int cnt){
        if (kcal > limit) {
            return;
        }
        maxScore = Math.max(maxScore, score);
        for (int i = start; i<cnt; i++) {
            dfs(cal, i+1, kcal + cal[i][1], score + cal[i][0], cnt);
        }
    }

	public static void main(String args[]) throws Exception
	{
		/*
		   표준입력 System.in 으로부터 스캐너를 만들어 데이터를 읽어옵니다.
		 */
		Scanner sc = new Scanner(System.in);
		int T;
		T=sc.nextInt();
		/*
		   여러 개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
		*/
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		for(int test_case = 1; test_case <= T; test_case++)
		{
		
			/////////////////////////////////////////////////////////////////////////////////////////////
			int cnt = sc.nextInt();
            limit = sc.nextInt();
            maxScore = 0;

            int[][] cal = new int[cnt][2];

            for(int i = 0; i<cnt; i++){
                cal[i][0] = sc.nextInt();    // 재료 점수
                cal[i][1] = sc.nextInt();    // 재료 칼로리
            }

            // for 돌면서 시작점 잡아서 dfs
            for(int i = 0; i<cnt; i++){
                dfs(cal, i, 0, 0, cnt);
            }

            bw.write("#" + test_case + " " + maxScore + "\n");
			/////////////////////////////////////////////////////////////////////////////////////////////
		}
        bw.flush();
        bw.close();
	}
}
```
- 이 부분 처음에 답이 안 나왔던 부분이 여기이다.
```java
for (int i = start; i<cnt; i++) {
    dfs(cal, i+1, kcal + cal[i][1], score + cal[i][0], cnt);
    maxScore = Math.max(maxScore, score);
}
```
- 처음에는 이렇게 maxScore 로직을 안에 뒀었는데, 
- 이렇게 하게 되면, dfs 호출 이후에 부모 노드의 score를 비교하는 방식인데,
- 즉, 자식 노드들이 모두 탐색된 이후에 현재 노드의 점수를 비교하는 식으로 가게 된다.

- 이렇게 되면, DFS 백트래킹 로직이 깨진다!!
  - DFS에서는 보통
  1. 새로운 조합의 점수 검증
  2. 자식 노드를 재귀 호출
  3. 끝나고 돌아감
  - 인데, 내가 원래 풀었던 방식대로 하면, 자식 노드를 탐색하는 중간중간의 값 갱신이 비어버린다.
  - 자식 호출을 거친 후의 score만 갱신하기 때문이다. 항상 자식 거친 뒤가 아니라, 부모의 score만 반영하게 되기 때문이다.

> 그래서 DFS 풀때는, 갱신시 모든 조합을 다 비교할 수 있도록
>
> 조건을 통과하면 자식 트리로 흘러갔을때 비교 값을 반영할 수 있도록 하자.

- 🍀 참고로 이 문제는, 모든 조합을 구하는 완전탐색 문제라서 dfs 재귀를 활용한다.
