## 풀이
- 너무 오랜만에 풀어서 좀 헤맸다.
- height를 정렬해서 빼는 방식으로 풀었는데
- 이거 중요한 것은, 뺄 때 height도 같이 빼는 것이다.
- 그나저나 자기들이 scanner로 test_case 받아오게 해두고 이걸 하드코딩으로 바꿔야 하는 경우는 대체 뭔 경우지

```java
import java.io.*;
import java.lang.*;
import java.util.*;

/*
   사용하는 클래스명이 Solution 이어야 하므로, 가급적 Solution.java 를 사용할 것을 권장합니다.
   이러한 상황에서도 동일하게 java Solution 명령으로 프로그램을 수행해볼 수 있습니다.
 */
class Solution
{
	public static void main(String args[]) throws Exception
	{
		/*
		   표준입력 System.in 으로부터 스캐너를 만들어 데이터를 읽어옵니다.
		 */
		Scanner sc = new Scanner(System.in);
		//int T;
		//T=sc.nextInt();
        int T = 10;
		/*
		   여러 개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
		*/
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

		for(int test_case = 1; test_case <= T; test_case++)
		{
		
			/////////////////////////////////////////////////////////////////////////////////////////////
            int answer = 0;
            
            int num = sc.nextInt();
            int[] building = new int[num];
            int[] height = new int[num];
            
            for(int i = 0; i<num; i++) { 
                int h = sc.nextInt();
                building[i] = h;
                height[i] = h;
            }
            
            Arrays.sort(height);   // 그냥 정렬하면 된다.
            
            for(int h : height) { 
                // 전부다 빼기
                for(int i = 0; i< num; i++){
                    building[i] -= h;
                    height[i] -= h;
                }
                // 5개씩 검사, 좌변
                List<Integer> minusBuilding = new ArrayList<Integer>();

                for(int i = 2; i<num-2; i++){
                    if(building[i] > 0 && building[i-2] <= 0 && building[i-1] <= 0 && building[i+1] <= 0 && building[i+2] <= 0){
                        minusBuilding.add(i);
                        answer += building[i];
                    }
                }
                for(int minus : minusBuilding){
                    building[minus] = 0;  //이미 더한 값은 지운다.
                }
            }
            bw.write("#" + test_case + " " + answer + "\n");
			/////////////////////////////////////////////////////////////////////////////////////////////
		}
        bw.flush();
        bw.close();
	}
}
```
- 개인적으로는 height 검사하고 빼는 방식 때문에 풀이가 지저분하다고 생각하는데
- 더 나은 풀이가 있는지 모르겠다.

## 어드바이스

- 있는 그대로 풀긴 했는데 이 풀이는 너무 복잡하다!!
- 이 문제의 쟁점은, 다섯 칸 중에 가장 긴 부분의 남는 것을 구하면 되는 문제이므로, 
- 주변 다섯개 중에 가장 긴거 구해서, 현재 가운데 건물이 그거보다 크면 더하면 된다.

## 최종 풀이
```java
import java.io.*;
import java.lang.*;
import java.util.*;

/*
   사용하는 클래스명이 Solution 이어야 하므로, 가급적 Solution.java 를 사용할 것을 권장합니다.
   이러한 상황에서도 동일하게 java Solution 명령으로 프로그램을 수행해볼 수 있습니다.
 */
class Solution
{
	public static void main(String args[]) throws Exception
	{
		/*
		   표준입력 System.in 으로부터 스캐너를 만들어 데이터를 읽어옵니다.
		 */
		Scanner sc = new Scanner(System.in);
		//int T;
		//T=sc.nextInt();
        int T = 10;
		/*
		   여러 개의 테스트 케이스가 주어지므로, 각각을 처리합니다.
		*/
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

		for(int test_case = 1; test_case <= T; test_case++)
		{
		
			/////////////////////////////////////////////////////////////////////////////////////////////
            int answer = 0;
            
            int num = sc.nextInt();
            int[] building = new int[num];
            
            for(int i = 0; i<num; i++) { 
                building[i] = sc.nextInt();
            }

            for(int i = 2; i<num-2; i++) {
                int maxAround = Math.max(
                    Math.max(building[i-2], building[i-1]),
                	Math.max(building[i+2], building[i+1])
                );
                
                if(building[i] > maxAround){
                    answer += building[i] - maxAround;
                }
            }
            
            bw.write("#" + test_case + " " + answer + "\n");
			/////////////////////////////////////////////////////////////////////////////////////////////
		}
        bw.flush();
        bw.close();
	}
}
```
- 이렇게 간단하게 생각하는게 참 아직 어려운데,
- 문제에서 요구하는 핵심이 뭔지를 잘 파악하자...모든 문제는 단순한 파훼법이 있으니 (물론 대부분의 경우인것이다. 아닌 경우도 있음)