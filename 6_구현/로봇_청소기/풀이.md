## 첫 풀이
```java
/**
 1. 현재 칸이 비어있으면 현재 칸을 청소한다.
 2. 4방향에 0이 아닌 수 밖에 없으면 청소할 수 없는거라 후진, 1이어서 벽이면 후진 못한다.
 2-1. 후진하고 다시 1로 돌아간다.
 3. 4방향에 0이 하나라도 있으면 Stack을 이용해서 반대 방향으로 돌리면서 (북 > 서 > 남 > 동) 앞을 체크한다.
 3-1. 갈 수 있으면 전진하고 다시 1로 돌아간다.
 **/

import java.util.*;
import java.lang.*;
import java.io.*;

public class 로봇_청소기{
    public static ArrayDeque<Integer> que;
    public static HashMap<Integer, int[]> NSEW;

    public boolean isTruInd(int x, int y, int n, int m){
        if((0<=x && x<m) && (0<=y && y<n)){
            return true;
        }
        return false;
    }

    public int spinAndForward(int dir, int[] robot, String[][] map, int n, int m){
        for(int i = 0; i<4; i++){
            que.addLast(dir);
            dir = que.pollFirst();

            int[] direct = NSEW.get(dir);
            int nextX = direct[0] + robot[0];
            int nextY = direct[1] + robot[1];
            if(isTruInd(nextX,nextY, n, m) && "0".equals(map[nextY][nextX])){
                robot[0] = nextX;
                robot[1] = nextY;
                return dir;
            }
        }
        return dir;
    }

    // 후진
    public boolean backUp(int dir, int[] robot, String[][] map, int n, int m){
        int opposite = ((dir + 2) % 4);
        int[] direct = NSEW.get(opposite);
        int nextX = direct[0] + robot[0];
        int nextY = direct[1] + robot[1];

        if(isTruInd(nextX,nextY, n, m) && !("1".equals(map[nextY][nextX]))){    // 벽
            robot[0] = nextX;
            robot[1] = nextY;
            return true;
        }
        return false;
    }

    //방향 탐색기
    public boolean searchAround(int[] robot, String[][] map, int n, int m){
        for(int i = 0; i<4; i++){
            int[] direct = NSEW.get(i);
            int nextX = direct[0] + robot[0];
            int nextY = direct[1] + robot[1];

            if(isTruInd(nextX,nextY, n, m) && "0".equals(map[nextY][nextX])){
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int answer = 0;

        // 청소판 위치
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        // 로봇 청소기 처음 위치
        st = new StringTokenizer(br.readLine());
        int r = Integer.parseInt(st.nextToken());
        int c = Integer.parseInt(st.nextToken());
        int dir = Integer.parseInt(st.nextToken());

        // map 만들기
        String[][] map = new String[n][m];
        for(int i = 0; i<n; i++){
            map[i] = br.readLine().split(" ");
        }

        que = new ArrayDeque<Integer>();
        NSEW = new HashMap<Integer, int[]>();
        // 반대 방향으로 넣기
        for(int i = 0; i<4; i++){
            que.addLast((4-dir-i) % 4);
        }
        NSEW.put(0, new int[]{0,-1});  //북
        NSEW.put(1, new int[]{1,0});  //동
        NSEW.put(2, new int[]{0,1});  //남
        NSEW.put(3, new int[]{-1,0});  //서

        int[] robot = new int[2];
        robot[0] = c;
        robot[1] = r;

        로봇_청소기 sol = new 로봇_청소기();

        while(true){
            if("0".equals(map[robot[1]][robot[0]])){
                map[robot[1]][robot[0]] = "2";
                answer++;
            }else{
                if(!sol.searchAround(robot, map, n, m)){
                    if(!sol.backUp(dir, robot, map, n, m)){
                        break;
                    }
                }else{
                    dir = sol.spinAndForward(dir, robot, map, n, m);
                }
            }
        }
        System.out.println(answer);
    }
}
```
- 일단 풀란대로 풀되 최대한 method로 분리해서 복잡하지 않게 했는데
- 왜인지 요구사항 다 만족 했는데 답이 다름. 이유를 모르겠다.

## 1차 디버깅

- 가장 남쪽 줄의 가장 동쪽 칸이라는게 결국 y,x라는 의미이다...이거 겁나게 헷갈리는데 줄과 칸이라는 용어를 주의하길 왜 이런식으로 표현하는 거냐...?
- 근데 고쳐도 안 된다...스트레스 받는다.
- 아 결국, 회전을 한 다음에 봐야하는데 현재 방향을 보고 가는게 문제라고 한다. 이 부분 고쳤다.
```java
/**
 1. 현재 칸이 비어있으면 현재 칸을 청소한다.
 2. 4방향에 0이 아닌 수 밖에 없으면 청소할 수 없는거라 후진, 1이어서 벽이면 후진 못한다.
 2-1. 후진하고 다시 1로 돌아간다.
 3. 4방향에 0이 하나라도 있으면 Stack을 이용해서 반대 방향으로 돌리면서 (북 > 서 > 남 > 동) 앞을 체크한다.
 3-1. 갈 수 있으면 전진하고 다시 1로 돌아간다.
 **/

import java.util.*;
import java.lang.*;
import java.io.*;

public class 로봇_청소기{
    public static ArrayDeque<Integer> que;
    public static HashMap<Integer, int[]> NSEW;

    public boolean isTruInd(int x, int y, int n, int m){
        if((0<=x && x<m) && (0<=y && y<n)){
            return true;
        }
        return false;
    }

    public int spinAndForward(int dir, int[] robot, String[][] map, int n, int m){
        for(int i = 0; i<4; i++){
            que.addLast(dir);
            dir = que.pollFirst();

            int[] direct = NSEW.get(dir);
            int nextX = direct[0] + robot[0];
            int nextY = direct[1] + robot[1];
            if(isTruInd(nextX,nextY, n, m) && "0".equals(map[nextY][nextX])){
                robot[0] = nextX;
                robot[1] = nextY;
                return dir;
            }
        }
        return dir;
    }

    // 후진
    public boolean backUp(int dir, int[] robot, String[][] map, int n, int m){
        int opposite = ((dir + 2) % 4);
        int[] direct = NSEW.get(opposite);
        int nextX = direct[0] + robot[0];
        int nextY = direct[1] + robot[1];

        if(isTruInd(nextX,nextY, n, m) && !("1".equals(map[nextY][nextX]))){    // 벽
            robot[0] = nextX;
            robot[1] = nextY;
            return true;
        }
        return false;
    }

    //방향 탐색기
    public boolean searchAround(int[] robot, String[][] map, int n, int m){
        for(int i = 0; i<4; i++){
            int[] direct = NSEW.get(i);
            int nextX = direct[0] + robot[0];
            int nextY = direct[1] + robot[1];

            if(isTruInd(nextX,nextY, n, m) && "0".equals(map[nextY][nextX])){
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int answer = 0;

        // 청소판 위치
        StringTokenizer st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken());

        // 로봇 청소기 처음 위치
        st = new StringTokenizer(br.readLine());
        int r = Integer.parseInt(st.nextToken());
        int c = Integer.parseInt(st.nextToken());
        int dir = Integer.parseInt(st.nextToken());

        // map 만들기
        String[][] map = new String[n][m];
        for(int i = 0; i<n; i++){
            map[i] = br.readLine().split(" ");
        }

        que = new ArrayDeque<Integer>();
        NSEW = new HashMap<Integer, int[]>();
        // 반대 방향으로 넣기
        for(int i = 0; i<4; i++){
            que.addLast((4-dir-i) % 4);
        }
        NSEW.put(0, new int[]{0,-1});  //북
        NSEW.put(1, new int[]{1,0});  //동
        NSEW.put(2, new int[]{0,1});  //남
        NSEW.put(3, new int[]{-1,0});  //서

        int[] robot = new int[2];
        robot[0] = c;
        robot[1] = r;

        로봇_청소기 sol = new 로봇_청소기();

        while(true){
            if("0".equals(map[robot[1]][robot[0]])){
                map[robot[1]][robot[0]] = "2";
                answer++;
            }else{
                if(!sol.searchAround(robot, map, n, m)){
                    if(!sol.backUp(dir, robot, map, n, m)){
                        break;
                    }
                }else{
                    dir = sol.spinAndForward(dir, robot, map, n, m);
                }
            }
        }
        System.out.println(answer);
    }
}
```
- NullPointerException이 난다...도대체 왜?
- 지금 풀이의 경우는 사실 너무 복잡해서 디버깅 불가라 에러 잡을 엄두가 안난다.
- 그래서 더 간단한 풀이가 가능한지 보기로, 내가 왜 이렇게 복잡하게 짤 수 밖에 없었는지, 뭘 놓친건지 보기로 했다.

