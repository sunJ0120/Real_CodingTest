## 첫 풀이
```java
import java.io.*;
import java.util.*;
import java.lang.*;

public class Main{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder stb = new StringBuilder();
        int num = Integer.parseInt(br.readLine());

        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] moves = new int[num];
        //1. 배열화
        for(int i = 0; i<num; i++){
            moves[i] = Integer.parseInt(st.nextToken());
        }

        int[] answer = new int[num];

        //2. 뒤부터 자리 찾기
        for(int i = num; i>0; i--){  // i는 사람 (숫자)
            int cnt = 0;   // cnt는 위치 비교
            int move = moves[i-1];
            for(int j = 0; j<num; j++){  // j는 위치 탐색
                if(answer[j] != 0){  // 못 들어가는 자리이므로, 비어 있지 않은지 먼저 체크
                    continue;
                }
                if(move == cnt){
                    answer[j] = i;
                    break;
                }
                cnt++;
            }
        }

        for(int ans : answer){
            stb.append(ans);
            stb.append(" ");
        }

        //3. 뒤집기
        System.out.println(stb.reverse().delete(0,1));
    }
}
```
- 일반 배열로 위치 찾아서 넣는 방식을 썼는데
- 논리적 오류가 있는지 틀렸음
- **근데 이렇게 풀면 사실상 로직이 너무 복잡해서 논리적 오류도 못잡는다.**

## 아이디어
- 이 문제의 경우는 결국 낑겨넣는걸 어떻게 해결하느냐의 문제라
- 이럴 경우 동적 배열을 이용하는게 맘 편하다.
- add(int index, E element)
  Inserts the specified element at the specified position in this list.
  - 애초에 ArrayList의 add 방식이 insert이므로, 이걸 이용한다

## 풀이 

### 1차
```java
import java.io.*;
import java.util.*;
import java.lang.*;

public class 줄_세우기{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder stb = new StringBuilder();
        int num = Integer.parseInt(br.readLine());

        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] moves = new int[num];
        //1. 배열화
        for(int i = 0; i<num; i++){
            moves[i] = Integer.parseInt(st.nextToken());
        }

        List<Integer> answer = new ArrayList<Integer>();
        for(int i = 0; i<num; i++){  // i는 인덱스
            answer.add(moves[i], i+1);
        }

        for(int ans : answer){
            stb.append(ans);
            stb.append(" ");
        }

        //3. 뒤집기
        System.out.println(stb.reverse().delete(0,1));
    }
}
```
- 로직 자체는 맞음 근데 문제가 뭐냐면
- 이렇게 reverse를 할 경우, string이 싹 뒤집혀서 두 자릿수 이상일때는 깨짐
```java
10
0 1 0 3 2 1 1 2 6 8
4 01 2 9 5 1 6 8 7 3
```

- 그래서 애초에 뒤에서부터 넣는게 맞음

### 2차 - 최종
```java
import java.io.*;
import java.util.*;
import java.lang.*;

public class 줄_세우기{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder stb = new StringBuilder();
        int num = Integer.parseInt(br.readLine());

        StringTokenizer st = new StringTokenizer(br.readLine());
        int[] moves = new int[num];
        //1. 배열화
        for(int i = 0; i<num; i++){
            moves[i] = Integer.parseInt(st.nextToken());
        }

        List<Integer> answer = new ArrayList<Integer>();
        for(int i = 0; i<num; i++){  // i는 인덱스
            answer.add(moves[i], i+1);
        }

        for(int i = answer.size()-1; i>=0; i--){
            stb.append(answer.get(i));
            if(i > 0){
                stb.append(" ");
            }
        }

        //3. 뒤집기
        System.out.println(stb);
    }
}
```

메모리 :	14208KB | 시간 : 100ms