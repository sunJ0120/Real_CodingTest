## 풀이

### 첫 풀이
```java

import java.util.*;
import java.io.*;
import java.lang.*;

public class 톱니바퀴{
    public static boolean isSpin(int[][] wheels, int ind, int[] startInds, int nextInd){
        int targetInd = startInds[ind];
        // 2. 내가 짝수면 2번 인덱스, 아니면 6번 인덱스를 가지고 비교한다.
        if(ind % 2 == 0){
            targetInd = (targetInd + 2) % 8;
            int nextTargetInd = (startInds[nextInd] + 6) % 8;

            if(wheels[ind][targetInd] != wheels[nextInd][nextTargetInd]){
                return true;
            }
            return false;
        }else{
            targetInd = (targetInd + 6) % 8;

            int nextTargetInd = (startInds[nextInd] + 2) % 8;

            if(wheels[ind][targetInd] != wheels[nextInd][nextTargetInd]){
                return true;
            }
            return false;
        }
    }
    // 1. 해당하는 것의 오른쪽 왼쪽을 따로 구해야 한다.
    public static void spin(int[] startInds, int[][] wheels, int ind, int dir){
        List<int[]> spinInds = new ArrayList<int[]>();
        spinInds.add(new int[]{ind,dir});

        //왼쪽
        int leftDir = dir;
        for(int i = ind-1;i>=0; i--){
            if(leftDir == 1){
                leftDir = -1;
            }else{
                leftDir = 1;
            }

            if(isSpin(wheels, i+1, startInds, i)){
                int[] li = {i,leftDir};
                spinInds.add(li);
            }
        }

        // 오른쪽
        int rightDir = dir;
        for(int i = ind+1;i<4; i++){
            if(rightDir == 1){
                rightDir = -1;
            }else{
                leftDir = 1;
            }

            if(isSpin(wheels, i-1, startInds, i)){
                int[] li = {i,rightDir};
                spinInds.add(li);
            }
        }

        // 회전시킨다.
        for(int[] spinInd : spinInds){
            startInds[spinInd[0]] = (startInds[spinInd[0]] + spinInd[1] + 8) % 8;
        }
    }

    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int[][] wheels = new int[4][8];
        for(int i = 0; i<4; i++){
            char[] ch = br.readLine().toCharArray();
            for(int j = 0; j<8; j++){
                wheels[i][j] = ch[j] - '0';
            }
        }

        int roop = Integer.parseInt(br.readLine());
        int[] startInds = new int[4];
        for(int i = 0; i<roop; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int num = Integer.parseInt(st.nextToken());    // 톱니 번호
            int dir = Integer.parseInt(st.nextToken());    // 방향

            spin(startInds, wheels, num-1, dir);
        }

        // startInd에 누적해서 값 구하기
        int ans = 0;
        for(int i = 0;i<4; i++){
            int startInd = startInds[i];
            if(wheels[i][startInd] == 1){    // 12시 방향이 S극이면
                ans += Math.pow(2,i);
            }
        }
        System.out.println(ans);
    }
}
```
- 논리적으로 여러가지 틀린 부분이 있다.
- 정리하자면 다음과 같다.

1. leftDir = -1; 일단 이건 굳이 이렇게 할 필요가 없음
- 그냥 -leftDir 이렇게 하면 반대로 할 수 있다.
2. ind % 2 == 0 이게 짝수이면 이런식으로 했는데, 짝수이면 그런게 아니라 왼쪽 오른쪽 어느 방향으로 갈지에 따라 방향이 반대가 된다.
- 그러므로 nextInd대비 내가 큰지 작은지 (왼쪽 오른쪽)을 따져서 작성해야 한다.
3. if(isSpin(wheels, i-1, startInds, i)) : 여기서 회전을 못하는 상황이면 전파를 끝내야 한다.
- 그러므로 break으로 빼주는 것이 좋다
4. (startInds[spinInd[0]] + spinInd[1] + 8) % 8; : 이 회전 로직에서 방향이 반대가 되어야 한다.
- 왜냐하면 정방향으로 돌아가면 startInd가 뒤로 가는 것이기 때문에 -spinInd[1]로 해야한다.

## 1차 풀이
```java
import java.util.*;
import java.io.*;
import java.lang.*;

public class 톱니바퀴{
    public static boolean isSpin(int[][] wheels, int ind, int[] startInds, int nextInd){
        // 나의 왼쪽이 nextInd이면, 내가 6번, 상대가 2번
        if(ind > nextInd){
            int targetInd = (startInds[ind] + 6) % 8;
            int nextTargetInd = (startInds[nextInd] + 2) % 8;

            if(wheels[ind][targetInd] != wheels[nextInd][nextTargetInd]){
                return true;
            }
            return false;
        }else{
            int targetInd = (startInds[ind] + 2) % 8;
            int nextTargetInd = (startInds[nextInd] + 6) % 8;

            if(wheels[ind][targetInd] != wheels[nextInd][nextTargetInd]){
                return true;
            }
            return false;
        }
    }
    // 1. 해당하는 것의 오른쪽 왼쪽을 따로 구해야 한다.
    public static void spin(int[] startInds, int[][] wheels, int ind, int dir){
        List<int[]> spinInds = new ArrayList<int[]>();
        spinInds.add(new int[]{ind,dir});

        //왼쪽
        int leftDir = dir;
        for(int i = ind-1;i>=0; i--){
            leftDir = -leftDir;    // 그냥 -1, 1 이므로 - 붙이면 된다.

            if(isSpin(wheels, i+1, startInds, i)){
                int[] li = {i,leftDir};
                spinInds.add(li);
            }else{    // 전파 방지
                break;
            }
        }

        // 오른쪽
        int rightDir = dir;
        for(int i = ind+1;i<4; i++){
            rightDir = -rightDir;

            if(isSpin(wheels, i-1, startInds, i)){
                int[] li = {i,rightDir};
                spinInds.add(li);
            }else{    // 전파 방지
                break;
            }
        }

        // 회전시킨다. **시계 방향이면 반대로 뒤로 가야한다.
        for(int[] spinInd : spinInds){
            startInds[spinInd[0]] = (startInds[spinInd[0]] - spinInd[1] + 8) % 8;
        }
    }

    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int[][] wheels = new int[4][8];
        for(int i = 0; i<4; i++){
            char[] ch = br.readLine().toCharArray();
            for(int j = 0; j<8; j++){
                wheels[i][j] = ch[j] - '0';
            }
        }

        int roop = Integer.parseInt(br.readLine());
        int[] startInds = new int[4];
        for(int i = 0; i<roop; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int num = Integer.parseInt(st.nextToken());    // 톱니 번호
            int dir = Integer.parseInt(st.nextToken());    // 방향

            spin(startInds, wheels, num-1, dir);
        }

        // startInd에 누적해서 값 구하기
        int ans = 0;
        for(int i = 0;i<4; i++){
            int startInd = startInds[i];
            if(wheels[i][startInd] == 1){    // 12시 방향이 S극이면
                ans += Math.pow(2,i);
            }
        }
        System.out.println(ans);
    }
}
```
### 메모리
14356KB

### 시간
96ms

- 일단 풀긴 했는데 내가 느낀 문제점은 다음과 같음
1. 방향 바꿔서 spinInds안에 list로 저장하는 방식이..좀 가시성이 안좋고 뭘 의미하는건지 딱 안보여서 실전에서 못 쓸 것 같음
2. 일단 돌릴 수 있는지 확인하고 한 번에 전파해야 답을 구할 수 있는 방식이라 list에 저장해서 풀긴 했는데 이 방식이 맞나 의문이 든다.
3. 기본적으로 코드가 너무 길고 지저분한 것 같아서 최적의 풀이가 존재하는지 궁금하다.

# 리팩터링

- 실전에서 쓰기 좋은 습관을 들이기 위해 고쳐야 할 부분들을 체킹하자.
1. 방향 저장 방식은 list로 하면 가독성이 떨어진다. (풀다가 그래서 0번이 뭐였지..일케된다.) 그래서 실전에서는 간단한 클래스나 record를 쓰는게 좋다고 한다.
2. 먼저 확인하고 전파 : 이게 핵심. 이 문제의 핵심은 회전 전 상태로 파악해야 한다는 것이다... << 맞음 이게 매우 헷갈렸다.
3. 재귀로 전파하면 훨씬 효율적인데..

## 처음에 재귀로 풀려고 했던건 맞는데, 고민했던건 이거 양방향 재귀로 하면 덮어 씌워 지면서 무한루프가 될 것 같아서

그래서 이걸 해결하기 위해 방문 체크 필터링을 하는 방식이 있다.
```java
// from: 어디서 전파됐는지 (-1이면 시작점, 아니면 그 방향은 탐색 안 함)
static void rotate(int idx, int dir, int from) {
    // 왼쪽 전파 (from이 왼쪽이 아닐 때만)
    if (from != idx - 1 && idx > 0 && canRotate(idx, idx - 1)) {
        rotate(idx - 1, -dir, idx);
    }
    // 오른쪽 전파 (from이 오른쪽이 아닐 때만)
    if (from != idx + 1 && idx < 3 && canRotate(idx, idx + 1)) {
        rotate(idx + 1, -dir, idx);
    }
    // 나 회전
    top[idx] = (top[idx] - dir + 8) % 8;
}
```
- 이런식인데, from(또는 isVisit도 가능)으로 이전 인덱스의 어느 방향에서 왔는지를 보면, 이중 재귀에서 덮어씌워지지 않을 수 있다.
- 이렇게 안하면 1 갔다가 2 갔다가 다시 1가고 이런식으로 무한루프에 빠짐
- 재귀 방식이 일단 먼저 체크하고 전파로 바꿔나간다는 방식이랑 동일해서 이 문제의 나중 전파 방식을 구현하기 좋은!

> 그리고 참고로 이런류의 방향 & 회전 문제는 지금처럼 **인덱싱 % 나누기나 숫자 더해서 계산하는 방식이 많이 쓰이고**, 이거 실전에서 꽤나 헷갈리기에 주의하자.
> 
> 또한, 시계 반시계 이게 은근 헷갈리니 인덱스가 감소하는지 증가하는지는 꼭 **손으로 그려보자.**

## 최종 풀이 
```java
import java.util.*;
import java.lang.*;
import java.io.*;

public class 톱니바퀴 {
    private static final int WHEEL_CNT = 4;
    private static final int SAW_TOOTH = 8;

    // 인덱스 판단
    public static boolean isTrueInd(int ind){
        return ind >= 0 && ind < WHEEL_CNT;
    }

    // 회전 가능 여부 판단
    public static boolean canSpin(int[][] wheels, int currentInd, int nextInd, int[] start){
        int currentTooth;
        int nextTooth;

        if(currentInd < nextInd){  // 오른쪽으로 가고 있음
            currentTooth = (start[currentInd] + 2) % SAW_TOOTH;
            nextTooth = (start[nextInd] + 6) % SAW_TOOTH;
        }else{
            currentTooth = (start[currentInd] + 6) % SAW_TOOTH;
            nextTooth = (start[nextInd] + 2) % SAW_TOOTH;
        }

        return wheels[currentInd][currentTooth] != wheels[nextInd][nextTooth];
    }

    // 회전 재귀 메서드
    public static void spin(int[][] wheels, int[] start, int currentInd, int from, int dir){
        if(from >= currentInd && isTrueInd(currentInd-1) && canSpin(wheels, currentInd, currentInd-1, start)){   // 왼쪽
            spin(wheels, start, currentInd-1, currentInd, -dir);
        }

        if(from <= currentInd && isTrueInd(currentInd+1) && canSpin(wheels, currentInd, currentInd+1, start)){ // 오른쪽
            spin(wheels, start, currentInd+1, currentInd, -dir);
        }

        // spin을 못할 경우, 자기 자신의 start 변경, 회전 방향과 반대
        start[currentInd] = (start[currentInd] - dir + SAW_TOOTH) % SAW_TOOTH;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int[][] wheels = new int[WHEEL_CNT][SAW_TOOTH];
        for(int i = 0; i<WHEEL_CNT; i++){
            char[] tooths = br.readLine().toCharArray();
            for(int j = 0; j<SAW_TOOTH; j++){
                wheels[i][j] = tooths[j] - '0';
            }
        }

        int[] start = new int[WHEEL_CNT];
        int ans = 0;

        int roop = Integer.parseInt(br.readLine());
        for(int i = 0; i<roop; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int ind = Integer.parseInt(st.nextToken());    // 톱니 인덱스
            int dir = Integer.parseInt(st.nextToken());    // 회전 방향
            spin(wheels, start, ind-1, ind-1, dir);
        }

        // start에 있는거 전부 더하기
        for(int i = 0; i<WHEEL_CNT; i++){
            int startInd = start[i];
            ans += (wheels[i][startInd] * Math.pow(2, i));
        }
        System.out.println(ans);
    }
}
```
- 처음에 isTrueInd에서 currentInd를 넘겨서 문제가 됐었는데, **이 다음이 있는지를 보는 것이므로** 다음 인덱스를 방향에 따라 넘기도록 하자.
- 시간은 쪼금 더 많이 걸렸지만, 재귀를 이용해서 훨씬 더 가독성 좋은 코드가 완성 되었다. 
- 또한 이정도면 실전 코테에서도 무리없이 쓸 수 있는 수준....

### 메모리
14280KB

### 시간
104ms