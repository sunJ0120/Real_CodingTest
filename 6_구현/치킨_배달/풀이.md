# 풀이

```java
import java.util.*;
import java.lang.*;
import java.io.*;

public class 치킨_배달{
    public static int answer = Integer.MAX_VALUE;

    public static int direct(List<int[]> chooses, int[][] map, int n){
        int ans = 0;

        for(int i = 0; i<n; i++){
            for(int j = 0; j<n; j++){
                if(map[i][j] == 1){
                    int minn = Integer.MAX_VALUE;
                    for(int[] choose : chooses){   // 1이면 가장 가까운 치킨 거리를 구해야 한다.
                        int dir = Math.abs(i - choose[1]) + Math.abs(j - choose[0]);
                        minn = Math.min(minn, dir);
                    }
                    ans += minn;
                }
            }
        }

        return ans;
    }

    public static void choose(List<int[]> chickens, int[][] map,
                              int n, int m, int start, List<int[]> chooses){
        if(chooses.size() == m){
            answer = Math.min(answer,direct(chooses, map, n));
            return;
        }

        if(chooses.size() < m && chooses.size() > 0){
            answer = Math.min(answer,direct(chooses, map, n));
        }

        for(int i = start; i<chickens.size(); i++){
            chooses.add(chickens.get(i));
            choose(chickens, map, n, m, i+1, chooses);
            chooses.remove(chooses.size()-1);    // 백트래킹, 새로운 가지를 넣기 위함
        }
    }

    public static List<int[]> store(int[][] map, int n){
        List<int[]> chickens = new ArrayList<int[]>();

        for(int i = 0; i<n; i++){
            for(int j = 0; j<n; j++){
                if(map[i][j] == 2){
                    chickens.add(new int[]{j, i});
                }
            }
        }

        return chickens;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        int n = Integer.parseInt(st.nextToken());
        int m = Integer.parseInt(st.nextToken()); // 최대 치킨집

        int[][] map = new int[n][n];
        for(int i = 0; i<n; i++){
            st = new StringTokenizer(br.readLine());
            for(int j = 0; j<n; j++){
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        List<int[]> chickens = store(map, n);    // 치킨 좌표
        choose(chickens, map, n, m, 0, new ArrayList<int[]>());

        System.out.println(answer);
    }
}
```
- 사실상 이 문제에서 중요한 것은, 복잡한 문제를 쪼개서 보는 능력이다.
- 나의 경우는 다음과 같이 접근했다.

1. 치킨 집은 최대 M개이다. >> 즉, M개 이하일 수도 있고, M개일 수도 있다. 그리고 치킨집은 2인 경우이므로 이 안에서 조합을 구해야 한다.
2. 치킨 집과 1 (집) 사이의 거리의 최소가 치킨거리이다. 즉, 내 집을 고르고, 그 집을 기준으로 있는 치킨 집 들과의 거리를 구한 다음 그것의 최소를 구해야 치킨 거리 하나를 구할 수 있다.

이렇게 나누면 작은 단위 기능은 다음과 같이 분리가 가능하다

1. 치킨집에 해당하는 list를 생성하는 기능 (조합으로 고르기 위해)
2. 치킨집을 고르는 기능 (백트래킹으로 리스트 안에 고른거 지우고, 조합으로 모든 경우의 수를 넣을 객체)
3. 골라진 치킨집과 사람들 집 간의 치킨 거리의 합을 구하는 기능

이 각각의 기능을 쓰여진 그대로 method로 분리해서 답을 구할 수 있었다.

- 풀어서 맞긴 했는데, 사실상 3중 for문이 상당히 신경쓰이긴 한다. 가독성이 구려서..


---


#### 메모리
19336KB

### 시간
228ms