
> 아 아이디어는 알겠는데 이런문제 진짜 너무너무 풀기가 싫다.
> 
> 드럽게 복잡하기만 한 드러운 깡구현 문제...
> 
> 진짜 하기 싫다.

------

### 아이디어 정리

나의 문제점은 이런 더러운 깡 구현 문제를 지겹도록 싫어한다는 것이다.

그러나 금융권 코테 단골이 이런 거지같은 깡 구현 문제 아니겠나..? 싫어도 해야한다.

그래서 앞으로 이런 드러운 깡 구현 문제는 다음과 같은 전략을 쓰기로 했다.

1. 문제 단위를 최대한 작게 나눈다.
2. 핵심 로직을 단계별로 쪼개서 표현한다.

### 풀이 전략

- 참고로 오늘 몸이 좀 안좋은데, 몸이 안 좋을때에 대한 전략도 세워둬야 실전 대비가 가능하니... (그리고 실전이라 긴장했을때도 지금과 같은 방식)
- 내 전략은, 최대한 하위 로직 단계를 글로 천천히 풀어 쓰며 안 돌아가는 머리를 붙잡고 천천히, 정확하게 이해하는 것이다.
- 포인트는 천천히임 천천히.. 급하게 가지 말자.

-------

## 첫 풀이

```java
import java.lang.*;
import java.util.*;
import java.io.*;

public class 창고_다각형{
    public static int areaCalcul(ArrayDeque<int[]> deque){
        int answer = 0;
        while(!deque.isEmpty()){
            int[] a = deque.pollFirst();
            if(!deque.isEmpty()){
                int[] top = deque.peekFirst();
                answer += Math.abs(top[0] - a[0]) * a[1];
            }
        }
        return answer;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int cnt = Integer.parseInt(br.readLine());
        StringTokenizer st;

        int[][] pillar = new int[cnt][2];
        ArrayDeque<int[]> deque = new ArrayDeque<int[]>();

        int answer = 0;
        int maxHeight = 0;
        int maxInd = 0;    // 1. 가장 긴거 인덱스 구한다.

        for(int i = 0; i<cnt; i++){
            st = new StringTokenizer(br.readLine());
            int x = Integer.parseInt(st.nextToken());
            int y = Integer.parseInt(st.nextToken());

            maxHeight = Math.max(maxHeight,y);

            pillar[i] = new int[]{x,y};
        }

        // x 기준으로 정렬하기
        Arrays.sort(pillar, (a,b) -> Integer.compare(a[0], b[0]));

        // maxInd 찾기
        for(int i = 0; i<cnt; i++){
            if(pillar[i][1] == maxHeight){
                maxInd = i;
                break;
            }
        }

        // 2. 왼쪽 넓이 구하기
        // 2-1. y가 증가추세면 올린다.
        deque.addLast(pillar[0]);
        for(int i = 1; i<=maxInd; i++){
            int[] top = deque.peekLast();
            if(top[1] <= pillar[i][1]){
                deque.addLast(pillar[i]);
            }
        }

        // 2-2. (top x - 뺀거 x) * 뺀거 y로 왼쪽 넓이 계산
        answer += areaCalcul(deque);

        // 3. 오른쪽 넓이 구하기
        // 3-1. 끝에서부터, y가 증가추세면 올린다.
        deque.addLast(pillar[cnt-1]);
        for(int i = cnt-2; i>=maxInd; i--){
            int[] top = deque.peekLast();
            if(top[1] <= pillar[i][1]){
                deque.addLast(pillar[i]);
            }
        }

        // 3-2. (top x - 뺀거 x) * 뺀거 y로 왼쪽 넓이 계산
        answer += areaCalcul(deque);

        answer += pillar[maxInd][1];

        System.out.println(answer);
    }
}
```
- 내가 다섯달 전에 풀었던 풀이에 비해 과도하게 어려워짐
- 있는 그대로 풀기는 했는데 디버깅 불가 코드가 되어버림
- 내가 뭔가 핵심을 못 잡고 있어서 그런거 같은데
- 뭐가 문젤까?

## 제안


