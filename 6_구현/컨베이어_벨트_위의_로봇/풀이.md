## 문제점

1. 컨베이어 벨트를 움직이는 것은 ArrayList로 끝에 있는걸 더하면서 살펴보면 된다는걸 알겠는데
2. 로봇이 움직이는게 문젠데 그럼 움직이는 로봇은 어떤 자료구조로 판단해서 로봇의 위치를 표현하고 -1을 해야 하는건지 전혀 감이 안잡힘
   3. list를 쓴다면, 한 번 돌때마다 계속 그 위치에 있는걸 다음 위치로 움직일 수 있는지 판단해서 움직여야 하는데 이게 맞나?
   4. 심지어 위치 움직이면서 영향 안받으려면 거꾸로 가야 하는거 아닌가. 이거 이렇게 어렵게 하는게 맞나?

- 원래 이런부류의 이동하는 문제는 이렇게 boolean 배열을 쓰는게 맞다고 한다.

## 첫 풀이..
```java
import java.lang.*;
import java.io.*;
import java.util.*;

public class 컨베이어_벨트_위의_로봇{
   public static void main(String[] args) throws IOException{
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      StringTokenizer st;

      st = new StringTokenizer(br.readLine());
      int n = Integer.parseInt(st.nextToken());    // 컨베이어 벨트 칸
      int k = Integer.parseInt(st.nextToken());    // 빈칸 갯수

      ArrayList<Integer> belt = new ArrayList<Integer>();    // 움직일 벨트
      boolean[] robot = new boolean[n];

      st = new StringTokenizer(br.readLine());
      while(st.hasMoreTokens()){
         belt.add(Integer.parseInt(st.nextToken()));
      }

      int cnt = 0;
      int zeroCnt = 0;    // 0의 갯수를 세서 체크하기 위함이다.

      while(zeroCnt < k){
         cnt++;
         // 1. 벨트를 회전시킨다.
         int end = belt.get(belt.size()-1);
         belt.remove(belt.size()-1);
         belt.add(0,end);

         // 2. 로봇도 회전(이동)시킨다. 뒤에서부터
         for(int i = n-1; i>0; i--){
            robot[i] = robot[i-1];
         }
         robot[0] = false;

         // 3. 로봇을 이동시킨다.
         // 3-1. true인 인덱스를 전부 뽑아야 한다.
         ArrayList<Integer> trueInd = new ArrayList<Integer>();
         for(int i = 0; i<n; i++){
            if(robot[i]){
               trueInd.add(i);
            }
         }
         // 3-2. true인 인덱스만 이동시킨다. 한칸
         if(!trueInd.isEmpty()){
            for(int ind : trueInd){  // 인덱스 안 넘치고, 로봇 없고, 다음꺼가 수명 남아 있으면
               if(ind+1 >= n){ // 끝자리
                  robot[ind] = false;  // 내보내야 함
               }else{
                  if(belt.get(ind+1) > 0){
                     robot[ind+1] = true;
                     int life = belt.get(ind+1)-1;
                     belt.remove(ind+1);    // 지우고 새로운거 더하기
                     belt.add(ind+1,life);
                  }
               }
            }
         }
         // 4. 로봇을 올린다.
         if(belt.get(0) > 0){
            robot[0] = true;
            int life = belt.get(0)-1;
            belt.remove(0);    // 지우고 새로운거 더하기
            belt.add(0,life);
         }
         // 5. 0의 갯수 세기
         zeroCnt = 0;
         for(int zero : belt){
            if(zero == 0){
               zeroCnt++;
            }
         }
      }
      System.out.println(cnt);
   }
}
```
- 정말 더럽고 마음에 안드는 풀이지만, 일단은 요구사항 그대로 풀었다.
- 일부 경우의수가 틀린데, 내가 보기엔 로직상의 문제는 없어서 검토가 필요하다.

## 두 번째 풀이..
```java
import java.lang.*;
import java.io.*;
import java.util.*;

public class 컨베이어_벨트_위의_로봇{
    public static void main(String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st;

        st = new StringTokenizer(br.readLine());
        int n = Integer.parseInt(st.nextToken());    // 컨베이어 벨트 칸
        int k = Integer.parseInt(st.nextToken());    // 빈칸 갯수

        ArrayList<Integer> belt = new ArrayList<Integer>();    // 움직일 벨트
        boolean[] robot = new boolean[n];

        st = new StringTokenizer(br.readLine());
        while(st.hasMoreTokens()){
            belt.add(Integer.parseInt(st.nextToken()));
        }

        int cnt = 0;
        int zeroCnt = 0;    // 0의 갯수를 세서 체크하기 위함이다.

        while(zeroCnt < k){
            cnt++;
            // 1. 벨트를 회전시킨다.
            int end = belt.get(belt.size()-1);
            belt.remove(belt.size()-1);
            belt.add(0,end);

            // 2. 로봇도 회전(이동)시킨다. 뒤에서부터
            for(int i = n-1; i>0; i--){
                robot[i] = robot[i-1];
                robot[i-1] = false; // *이전 위치 지움
            }

            if(robot[n-1]){    // 끝은 무조건 내리기
                robot[n-1] = false;
            }

            // 3. 로봇을 이동시킨다.
            for(int i = n-1; i>0; i--){
                if(robot[i-1]){  // 거꾸로 라서 i가 다음꺼
                    if(belt.get(i) > 0){
                        robot[i] = true;
                        robot[i-1] = false; // *이전 위치 지움, 이동

                        int newLife = belt.get(i)-1;
                        belt.remove(i);    // 지우고 새로운거 더하기
                        belt.add(i,newLife);
                    }
                }
            }

            // 4. 로봇을 올린다.
            if(belt.get(0) > 0){
                robot[0] = true;
                int life = belt.get(0)-1;
                belt.remove(0);    // 지우고 새로운거 더하기
                belt.add(0,life);
            }

            // 5. 0의 갯수 세기
            zeroCnt = 0;
            for(int zero : belt){
                if(zero == 0){
                    zeroCnt++;
                }
            }
        }
        System.out.println(cnt);
    }
}
```
- 왜인지 여전히 약간씩 다르다.
- 내가 뭘 놓치고 있는건지 어디를 잘못 접근했는지 도저히 모르겠다....
- 구라치지마 이거 belt랑 robot 인덱스 관리를 따로 해야 한다고? 이걸 실전에서 어케 푸는데

## 최종 풀이
```java
import java.io.*;
import java.util.*;

public class 컨베이어_벨트_위의_로봇 {
   public static void main(String[] args) throws IOException{
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
      StringTokenizer st = new StringTokenizer(br.readLine());

      int n = Integer.parseInt(st.nextToken());
      int k = Integer.parseInt(st.nextToken());

      ArrayList<Integer> belt = new ArrayList<>();
      boolean[] robot = new boolean[n];

      st = new StringTokenizer(br.readLine());
      while(st.hasMoreTokens()){
         belt.add(Integer.parseInt(st.nextToken()));
      }

      int cnt = 0;

      while(true){
         cnt++;

         // 1. 벨트 회전
         int end = belt.get(belt.size()-1);
         belt.remove(belt.size()-1);
         belt.add(0, end);

         // 2. 로봇 회전
         for(int i = n-1; i > 0; i--){
            robot[i] = robot[i-1];
         }
         robot[0] = false;    // 처음 위치
         robot[n-1] = false;  // 내리는 위치는 로봇이 못온다.

         // 3. 로봇 이동 (n-2부터, n-1은 이동 불가)
         for(int i = n-2; i >= 0; i--){  // n-2부터!
            if(robot[i] && !robot[i+1] && belt.get(i+1) > 0){
               robot[i] = false;
               robot[i+1] = true;
               belt.set(i+1, belt.get(i+1) - 1);    // set을 이용하면 된다.
            }
         }
         robot[n-1] = false;  // 이동 후에도 내림

         // 4. 로봇 올리기
         if(belt.get(0) > 0){
            robot[0] = true;
            belt.set(0, belt.get(0) - 1);
         }

         // 5. 0 개수 체크
         int zeroCnt = 0;
         for(int b : belt){
            if(b == 0) zeroCnt++;
         }

         if(zeroCnt >= k) break;
      }

      System.out.println(cnt);
   }
}
```

- 결론적으로 인덱스 관리는 내가 푼게 아니라서 다시 풀어야함
- 이딴 문제를 실전에서 어케 푸는데 이걸 다 고려해가면서 머리를 어떻게 굴리냐고 이런 더러운 문제를...