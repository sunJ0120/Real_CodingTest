## ì²« í’€ì´
```java
import java.lang.*;
import java.util.*;

class Solution {
    public static int m;
    public static int n;
    public static final int[] posX = {0,0,-1,1};
    public static final int[] posY = {-1,1,0,0};

    public boolean isTrueInd(int x, int y) {
        if((0 <= x && x < m) && (0 <= y && y < n)) {
            return true;
        }
        return false;
    }

    public void addQueue(boolean[][] isVisit, ArrayDeque<int[]> queue, int x, int y, int depth){
        int[] node = {x, y, depth};
        queue.addLast(node);
        isVisit[y][x] = true;
    }

    public int bfs(int[][] maps){
        // 1. ìš°ì„  isVisitë¥¼ ë§Œë“¤ì–´ì„œ ë°©ë¬¸ì„ ì²´í¬í•œë‹¤.
        boolean[][] isVisit = new boolean[n][m];
        // 2. ArrayDequeë¥¼ ë§Œë“¤ì–´ì„œ ë„£ëŠ”ë‹¤.
        ArrayDeque<int[]> queue = new ArrayDeque<int[]>();
        addQueue(isVisit, queue, 0, 0, 1);

        while(!queue.isEmpty()){
            // 3. topì—ì„œ forë¡œ 4ë°©í–¥ì„ ëŒë©´ì„œ ì²´í¬í•œë‹¤.
            int[] top = queue.pollFirst();
            int topX = top[0];
            int topY = top[1];
            int topDepth = top[2];

            // 5. x,yê°€ m,nê³¼ ê°™ì•„ì§€ë©´ depthë¥¼ ë‚´ë³´ë‚¸ë‹¤.
            if(topX == m-1 && topY == n-1){
                return topDepth;
            }

            for(int i = 0; i<4; i++){
                int nextX = topX + posX[i];
                int nextY = topY + posY[i];
                if(isTrueInd(nextX, nextY) && !isVisit[nextY][nextX] && maps[nextY][nextX] == 1){
                    // 4. ArrayDequeì— x, y, ë„£ìœ¼ë©´ì„œ depthë¥¼ ëŠ˜ë¦°ë‹¤.
                    addQueue(isVisit, queue, nextX, nextY, topDepth+1);
                }
            }
        }
        return -1;  // ëª»ê°
    }

    public int solution(int[][] maps) {
        // ğŸš¨ ì‹¤ìˆ˜ point : ì—¬ê¸° staticìœ¼ë¡œ í–ˆìœ¼ë©´, ì§€ì—­ë³€ìˆ˜ë¡œ ì„ ì–¸í•˜ì§€ ì•Šê²Œ ì£¼ì˜í•˜ì.
        m = maps[0].length;
        n = maps.length;

        return bfs(maps);
    }
}
```
- ì´ë ‡ê²Œ í’€ì—ˆëŠ”ë°, ì´ í’€ì´ì˜ ê²½ìš°ëŠ” ë‹¤ìŒì˜ ë¬¸ì œê°€ ìˆë‹¤ê³  í•œë‹¤.
1. int[] ë°°ì—´ ì‚¬ìš©ì˜ ë¬¸ì œì  (ë§¤ì§ ë„˜ë²„)
   - top[0]ì´ xì¸ì§€ yì¸ì§€ í—·ê°ˆë¦¼ (ì‹¤ìˆ˜í•˜ê¸° ì‰¬ì›€)
   - ë‚˜ì¤‘ì— ë´¤ì„ ë•Œ ì˜ë¯¸ íŒŒì•…ì´ ì–´ë ¤ì›€
   - ë§Œì•½ top[1]ê³¼ top[0]ì„ ë°”ê¿” ì¨ë„ ì»´íŒŒì¼ëŸ¬ê°€ ê°ì§€ ëª»í•¨
   - ìƒˆë¡œìš´ ì •ë³´ ì¶”ê°€í•˜ë ¤ë©´? int[4]ë¡œ ë°”ê¾¸ê³  ëª¨ë“  ì½”ë“œ ìˆ˜ì • í•„ìš”
2. static ë‚¨ë°œ
   - ìƒíƒœ ê³µìœ ë¡œ ì¸í•œ ë¬¸ì œ
     - ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤/ìŠ¤ë ˆë“œê°€ ê°™ì€ ë³€ìˆ˜ë¥¼ ê³µìœ 
     - í•œ ê³³ì—ì„œ ìˆ˜ì •í•˜ë©´ ë‹¤ë¥¸ ê³³ì—ë„ ì˜í–¥
   - ë©€í‹°ìŠ¤ë ˆë“œ í™˜ê²½ì—ì„œ ìœ„í—˜
     - ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ìˆ˜ì • â†’ ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•œ ê²°ê³¼
     - ì½”ë”© í…ŒìŠ¤íŠ¸ëŠ” ë‹¨ì¼ ìŠ¤ë ˆë“œì§€ë§Œ, ì‹¤ë¬´ì—ì„œëŠ” ì¹˜ëª…ì 
   - í…ŒìŠ¤íŠ¸í•˜ê¸° ì–´ë ¤ì›€
     - í…ŒìŠ¤íŠ¸ë¼ë¦¬ ìƒíƒœê°€ ê³µìœ ë˜ì–´ ë…ë¦½ì ì¸ í…ŒìŠ¤íŠ¸ ë¶ˆê°€ëŠ¥
     - ì‹¤í–‰ ìˆœì„œì— ë”°ë¼ ê²°ê³¼ê°€ ë‹¬ë¼ì§
   - ì¬ì‚¬ìš©ì„± ë–¨ì–´ì§
     - ê°™ì€ Solution ê°ì²´ë¡œ ë‹¤ë¥¸ ì…ë ¥ ì²˜ë¦¬ ì‹œ ì´ì „ ê°’ ë®ì–´ì”Œì›Œì§
     - ë©”ì„œë“œ í˜¸ì¶œë§ˆë‹¤ ë…ë¦½ì ì¸ ìƒíƒœ ìœ ì§€ ë¶ˆê°€

ê·¸ë˜ì„œ ì§„ì§œ í•„ìš”í•œ ë¶€ë¶„ë§Œ staticìœ¼ë¡œ ë°”ê¾¸ê³ , ë‚˜ë¨¸ì§€ëŠ” íŒŒë¼ë¯¸í„°ë¡œ ë„˜ê¸°ë„ë¡ ë¦¬íŒ©í„°ë§ì„ ì§„í–‰í–ˆë‹¤.

ë˜í•œ, int[] ë°°ì—´ ëŒ€ì‹  Node í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ì„œ ì•ˆì •ì„±ì„ ë†’ì˜€ë‹¤.

------

## ìµœì¢…
```java
import java.lang.*;
import java.util.*;

class Solution {
    static class Node{
        int x;
        int y;
        int depth;

        Node(int x, int y, int depth){
            this.x = x;
            this.y = y;
            this.depth = depth;
        }
    }

    public static final int[] posX = {0,0,-1,1};
    public static final int[] posY = {-1,1,0,0};

    public boolean isTrueInd(int x, int y, int m, int n) {
        if((0 <= x && x < m) && (0 <= y && y < n)) {
            return true;
        }
        return false;
    }

    public void addQueue(boolean[][] isVisit, ArrayDeque<Node> queue, int x, int y, int depth){
        Node node = new Node(x, y, depth);
        queue.addLast(node);
        isVisit[y][x] = true;
    }

    public int bfs(int[][] maps, int m, int n){
        // 1. ìš°ì„  isVisitë¥¼ ë§Œë“¤ì–´ì„œ ë°©ë¬¸ì„ ì²´í¬í•œë‹¤.
        boolean[][] isVisit = new boolean[n][m];
        // 2. ArrayDequeë¥¼ ë§Œë“¤ì–´ì„œ ë„£ëŠ”ë‹¤.
        ArrayDeque<Node> queue = new ArrayDeque<Node>();
        addQueue(isVisit, queue, 0, 0, 1);

        while(!queue.isEmpty()){
            // 3. topì—ì„œ forë¡œ 4ë°©í–¥ì„ ëŒë©´ì„œ ì²´í¬í•œë‹¤.
            Node top = queue.pollFirst();

            // 5. x,yê°€ m,nê³¼ ê°™ì•„ì§€ë©´ depthë¥¼ ë‚´ë³´ë‚¸ë‹¤.
            if(top.x == m-1 && top.y == n-1){
                return top.depth;
            }

            for(int i = 0; i<4; i++){
                int nextX = top.x + posX[i];
                int nextY = top.y + posY[i];
                if(isTrueInd(nextX, nextY, m, n) && !isVisit[nextY][nextX] && maps[nextY][nextX] == 1){
                    // 4. ArrayDequeì— x, y, ë„£ìœ¼ë©´ì„œ depthë¥¼ ëŠ˜ë¦°ë‹¤.
                    addQueue(isVisit, queue, nextX, nextY, top.depth+1);
                }
            }
        }
        return -1;  // ëª»ê°
    }

    public int solution(int[][] maps) {
        int m = maps[0].length;
        int n = maps.length;

        return bfs(maps, m, n);
    }
}
```

ê·¸ë˜ì„œ ë‹¤ìŒê³¼ ê°™ì´ ë¦¬íŒ©í„°ë§ì„ ì§„í–‰í–ˆë‹¤.

- ìš°ì„  Nodeë¥¼ ë”°ë¡œ ë§Œë“¤ì–´ì„œ int ë°°ì—´ë³´ë‹¤ ì•ˆì •ì„±ì„ ë†’ì„ (ì¸ë±ìŠ¤ ìˆ«ìì— ì˜ì§€í•˜ì§€ ì•ŠìŒ)
- isTrueIndì— m,nì„ íŒŒë¼ë¯¸í„°ë¡œ ë„˜ê²¨ì„œ static ë³€ìˆ˜ ì˜ì¡´ì„±ì„ ì¤„ì„
- topX, topY, topDepthë¥¼ ë”°ë¡œ ë¹¼ì§€ ì•Šê³  Nodeì—ì„œ ë°”ë¡œ ì ‘ê·¼í•˜ë„ë¡ ë³€ê²½,
  - Nodeê°€ ìˆìœ¼ë¯€ë¡œ, ë³€ìˆ˜ê°€ ì—†ì–´ë„ ì´í•´ê°€ ì‰¬ì›Œì„œ ê°€ëŠ¥í•œ ë¶€ë¶„