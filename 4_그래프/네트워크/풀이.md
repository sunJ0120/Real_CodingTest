## 첫 풀이

```java
import java.util.*;
import java.lang.*;

class Solution {
    public int solution(int n, int[][] computers) {
        int answer = 0;
        // 1. Map으로 연결 관계 list와 인덱스를 만든다.
        Map<Integer, List<Integer>> linked = new HashMap<>();
        boolean[] isVisit = new boolean[n];
        
        for(int i = 0; i<n; i++){
            int key = i;
            List<Integer> values = new ArrayList<>();
            // 연결된 정보 넣는다.
            for(int j = 0; j<n; j++){
                if(computers[i][j] == 1){
                    values.add(j);
                }
            }
            linked.put(key, values);
        }
        // 2. 깊이 우선 탐색으로 하나씩 방문 체크 하며 dfs로 들어간다.
        for(int i = 0; i<n; i++){
            // 3. 방문 했으면 dfs로 들어가지 말고 다음으로 넘어간다.
            if(isVisit[i]){
                continue;
            }
            // 4. 방문 안했을때 들어간다.
            dfs(i, linked, isVisit);
            answer++;
        }
        // 5. 연결된게 없으면 return으로 해당 루프를 나간다.
        return answer;
    }
    
    public void dfs(int start, Map<Integer, List<Integer>> linked, boolean[] isVisit){
        isVisit[start] = true;
        List<Integer> values = linked.get(start);
        if(values.size() == 0){    // 방문할 곳 없음
            return;
        }
        for(Integer value : values){
            if(!isVisit[value]){    // 방문 안 한 것만 들어가기
                dfs(value, linked, isVisit);
            }
        }
    }
}
```

## 참고

아 이거 굳이 Map을 사용할 필요가 없다!!! 배열 자체가 연결관계를 나타내기 때문에

개인적으로는 깊이 우선 탐색의 정수 같은 문제라고 생각한다!

메모리를 아끼기 위해 Map을 이용하지 말고 다시 풀어보장

------------

## 최종 풀이

```java
import java.util.*;
import java.lang.*;

class Solution {
    public int solution(int n, int[][] computers) {
        int answer = 0;
        boolean[] isVisit = new boolean[n];

        // 2. 깊이 우선 탐색으로 하나씩 방문 체크 하며 dfs로 들어간다.
        for(int i = 0; i<n; i++){
            // 3. 방문 했으면 dfs로 들어가지 말고 다음으로 넘어간다.
            if(isVisit[i]){
                continue;
            }
            // 4. 방문 안했을때 들어간다.
            dfs(i, computers, isVisit, n);
            answer++;
        }
        // 5. 연결된게 없으면 return으로 해당 루프를 나간다.
        return answer;
    }
    
    public void dfs(int start, int[][] computers, boolean[] isVisit, int size){
        isVisit[start] = true;
        for(int i = 0; i<size; i++){
            if(!isVisit[i] && computers[start][i] == 1){    // 방문 안 한 것만 들어가기
                dfs(i, computers, isVisit, size);
            }
        }
    }
}
```

### 정확도 테스트
```java
테스트 1 〉	통과 (0.02ms, 72.3MB)
테스트 2 〉	통과 (0.02ms, 89.4MB)
테스트 3 〉	통과 (0.02ms, 73.8MB)
테스트 4 〉	통과 (0.02ms, 87.2MB)
테스트 5 〉	통과 (0.02ms, 88.4MB)
테스트 6 〉	통과 (0.05ms, 72.9MB)
테스트 7 〉	통과 (0.02ms, 85.5MB)
테스트 8 〉	통과 (0.05ms, 75.8MB)
테스트 9 〉	통과 (0.05ms, 73.7MB)
테스트 10 〉	통과 (0.05ms, 86MB)
테스트 11 〉	통과 (0.14ms, 72.5MB)
테스트 12 〉	통과 (0.12ms, 71.1MB)
테스트 13 〉	통과 (0.07ms, 72.8MB)
```