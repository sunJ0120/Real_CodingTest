
## 내 풀이
```java
import java.util.*;
import java.lang.*;

class Node {
    int x;
    int y;
    int dist = 0;
    
    Node(int x, int y, int dist){
        this.x = x;
        this.y = y;
        this.dist = dist;
    }
    
    Node(int x, int y){
        this.x = x;
        this.y = y;
    }
}

class Solution {
    // 상 하 좌 우 
    // 4. 4가지 방향 (상하좌우) 설정한다.
    public static final int[] posX = {0,0,-1,1};
    public static final int[] posY = {-1,1,0,0};
    
    public int solution(String[] maps) {
        int answer = 0;
        
        int n = maps[0].length(); //x
        int m = maps.length; //y
        
        char[][] mapsToChar = new char[m][n];
        
        for(int i = 0; i<m; i++){
            mapsToChar[i] = maps[i].toCharArray();
        }
        // sToL
        int sToL = bfs(mapsToChar, n, m,'S','L');
        if(sToL == -1){
            return -1;
        }
        // lToE
        int lToE = bfs(mapsToChar, n, m,'L','E');
        if(lToE == -1){
            return -1;
        }

        return sToL + lToE;
    }
    
    // start 찾는 method
    public Node makeStartNode(char start, char[][] mapsToChar, int n, int m){
        for(int i = 0; i<m; i++){
            for(int j = 0; j<n; j++){
                if(mapsToChar[i][j] == start){
                    return new Node(j,i);
                }
            }
        }
        return null;
    }
    
    // 3. S > L && L > E 구한다.
    public int bfs(
        char[][] mapsToChar, 
        int n, int m, 
        char start, char end) 
    {
        // 1. 최단거리 이므로, 큐를 사용하기 위해 BFS 개념을 활용한다.
        ArrayDeque<Node> queue = new ArrayDeque<Node>();
        
        // 2. isVisit를 생성해서 체크한다.
        boolean[][] isVisit = new boolean[m][n];
        Node startNode = makeStartNode(start, mapsToChar, n, m);
        queue.addLast(startNode);
        isVisit[startNode.y][startNode.x] = true;
        
        // 5. pop해서 isVisit 체크하고 값을 저장한다.
        while(!queue.isEmpty()){
            Node top = queue.pollFirst();
            int topX = top.x;
            int topY = top.y;
            int dist = top.dist;
            // 8. end에 해당하면 dist return 한다.
            if(mapsToChar[topY][topX] == end){
                return dist;
            }
            // 6. 상하좌우로 이동한 값을 전부 큐에 넣는다.
            for(int i = 0; i<4; i++){
                // 7. 이때, 인덱스의 값이 유효한지 & X가 아닌지, isVisit 한적 없는지 체크한다.
                int nextX = topX + posX[i];
                int nextY = topY + posY[i];
                if(isTrueInd(nextX, nextY, n, m) 
                   && !isVisit[nextY][nextX] && mapsToChar[nextY][nextX] != 'X'){
                    queue.addLast(new Node(nextX, nextY, dist+1));
                    isVisit[nextY][nextX] = true;
                }
            }
        }
        return -1;
    }
    public boolean isTrueInd(int nextX, int nextY, int n, int m){
        if((0<= nextX && nextX < n) && (0 <= nextY && nextY < m)){
            return true;
        }
        return false;
    }
}
```
- 일단 Node를 따로 둬서, bfs로 넓이 우선 탐색을 함
- Node 안에 x,y,dist를 둬서 움직임과 지금까지의 거리를 저장
- 넓이 우선 탐색을 한 이유는, bfs는 depth가 같으므로 최단거리를 보장해서
  - 즉, 각 지점의 단계별 탐색 길이가 같다는 의미이다.
- 조언 받은 대로, L > E로 갈때 Visit 전부 초기화
- 큐와 visit은 bsf 각 분기에서만 사용 & 초기화 해야 하므로 안에 넣어서 초기화까지
- 반복은 최대한 method로 묶고 early return을 활용하려고 노력했는데, 코드가 지저분해서 맘에 들지는 않음..

### 정확성 체크
```java
테스트 1 〉	통과 (0.54ms, 75.9MB)
테스트 2 〉	통과 (0.41ms, 79.7MB)
테스트 3 〉	통과 (0.72ms, 78.1MB)
테스트 4 〉	통과 (0.44ms, 76.2MB)
테스트 5 〉	통과 (0.61ms, 73MB)
테스트 6 〉	통과 (0.67ms, 89.9MB)
테스트 7 〉	통과 (1.36ms, 87.1MB)
테스트 8 〉	통과 (1.66ms, 72.6MB)
테스트 9 〉	통과 (0.47ms, 83.9MB)
테스트 10 〉	통과 (0.35ms, 85.9MB)
테스트 11 〉	통과 (1.34ms, 107MB)
테스트 12 〉	통과 (3.56ms, 75.8MB)
테스트 13 〉	통과 (4.12ms, 79.6MB)
테스트 14 〉	통과 (2.02ms, 74.4MB)
테스트 15 〉	통과 (0.65ms, 79.7MB)
테스트 16 〉	통과 (4.16ms, 86.6MB)
테스트 17 〉	통과 (6.07ms, 80.5MB)
테스트 18 〉	통과 (0.58ms, 68.5MB)
테스트 19 〉	통과 (0.81ms, 88.8MB)
테스트 20 〉	통과 (3.72ms, 86MB)
테스트 21 〉	통과 (1.39ms, 76.1MB)
테스트 22 〉	통과 (0.80ms, 75.8MB)
테스트 23 〉	통과 (0.46ms, 75.8MB)
```