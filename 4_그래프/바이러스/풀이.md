## 풀이 
```java
import java.lang.*;
import java.io.*;
import java.util.*;

public class Main {
    public static int ans = 0;

    public void dfs(HashMap<Integer, ArrayList<Integer>> graph, int start, boolean[] isVisit){
        // 2. for문으로 돌면서 연결된 것을 다 돌아다닌다.
        ArrayList<Integer> values = graph.get(start);
        for(int value : values){
            if(!isVisit[value]){
                isVisit[value] = true;
                // 3. 방문 안한 노드이면 더해준다.
                ans++;
                dfs(graph, value, isVisit);
            }
        }
    }

    public void makeLink(HashMap<Integer, ArrayList<Integer>> graph, int node1, int node2){
        if(graph.containsKey(node1)){
            ArrayList<Integer> values = graph.get(node1);
            values.add(node2);
        }else{
            ArrayList<Integer> values = new ArrayList<Integer>();
            values.add(node2);
            graph.put(node1,values);
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int node = Integer.parseInt(br.readLine());
        int link = Integer.parseInt(br.readLine());
        HashMap<Integer, ArrayList<Integer>> graph = new HashMap<Integer, ArrayList<Integer>>();
        boolean[] isVisit = new boolean[node+1];
        isVisit[1] = true; // 시작 노드 더하기
        Main sol = new Main();

        for(int i = 0; i<link; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int node1 = Integer.parseInt(st.nextToken());
            int node2 = Integer.parseInt(st.nextToken());
            // 1. 양쪽으로 연결관계를 넣어준다.
            sol.makeLink(graph, node1, node2);
            sol.makeLink(graph, node2, node1);
        }
        sol.dfs(graph, 1, isVisit);
        System.out.println(ans);
    }
}
```
- 이거 같은 경우는, 결국 1번과 연결되어 있는 모든 노드를 방문하면 되기 때문에, 완전탐색으로 DSF 재귀를 이용했다.
- 갯수 같은 경우는 for문으로 연결된 전체 node를 탐색할때, 방문을 안한 노드이면 방문 표시를 하고 답을 더해주는 방식을 사용
- 이번에는 Map을 이용해서 연결관계를 표현했는데, method를 따로 빼서 연결된 두가지를 전부 표현할 수 있게 하였다.
- 이것만 있을 경우, 1 0 으로 주어져서 연결관계가 없을 경우 list가 없는 문제가 발생한다.

```java
import java.lang.*;
import java.io.*;
import java.util.*;

public class Main {
    public static int ans = 0;

    public void dfs(HashMap<Integer, ArrayList<Integer>> graph, int start, boolean[] isVisit){
        // 2. for문으로 돌면서 연결된 것을 다 돌아다닌다.
        ArrayList<Integer> values = graph.get(start);
        for(int value : values){
            if(!isVisit[value]){
                isVisit[value] = true;
                // 3. 방문 안한 노드이면 더해준다.
                ans++;
                dfs(graph, value, isVisit);
            }
        }
    }

    public void makeLink(HashMap<Integer, ArrayList<Integer>> graph, int node1, int node2){
        if(graph.containsKey(node1)){
            ArrayList<Integer> values = graph.get(node1);
            values.add(node2);
        }else{
            ArrayList<Integer> values = new ArrayList<Integer>();
            values.add(node2);
            graph.put(node1,values);
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int node = Integer.parseInt(br.readLine());
        int link = Integer.parseInt(br.readLine());
        HashMap<Integer, ArrayList<Integer>> graph = new HashMap<Integer, ArrayList<Integer>>();
        boolean[] isVisit = new boolean[node+1];
        isVisit[1] = true; // 시작 노드 더하기
        graph.put(1, new ArrayList<Integer>());
        Main sol = new Main();

        for(int i = 0; i<link; i++){
            StringTokenizer st = new StringTokenizer(br.readLine());
            int node1 = Integer.parseInt(st.nextToken());
            int node2 = Integer.parseInt(st.nextToken());
            // 1. 양쪽으로 연결관계를 넣어준다.
            sol.makeLink(graph, node1, node2);
            sol.makeLink(graph, node2, node1);
        }
        sol.dfs(graph, 1, isVisit);
        System.out.println(ans);
    }
}
```
- 그래서 초기값 같은 경우는 미리 arrayList를 넣어주었다
- 이렇게 하면 초기값에서 시작할때 연결 관계가 없어도 NullPointerException이 안난다.
- 개인적으로는,,,코드가 좀 더러워져서 마음에 안든다. 예외 사항도 있고

