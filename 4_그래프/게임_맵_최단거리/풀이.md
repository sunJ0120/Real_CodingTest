## 첫 풀이

```java
import java.util.*;
import java.lang.*;

class Solution {
    public static int[] xInd = {0,0,1,-1};
    public static int[] yInd = {1,-1,0,0};
    public static int answer = Integer.MAX_VALUE;
    
    public int solution(int[][] maps) {
        int m = maps.length;   // y
        int n = maps[0].length;    // x
        // 1. 0,0에서 출발한다.
        dfs(0, 0, n, m, maps, 1);
        // 5. answer가 여전히 Integer.MAX_VALUE면 값이 없는 것이므로 -1을 넣는다.
        if(answer == Integer.MAX_VALUE){
            answer = -1;
        }
        return answer;
    }
    
    public void dfs(int x, int y, int n, int m, int[][] maps, int dist){
        // 4. (n,m)에 도착하면 거리 min 값 비교해서 채운다.
        if(x == n-1 && y == m-1){
            answer = Math.min(dist, answer);
            return;
        }
        for(int i = 0; i < 4; i++){
            // 2. x,y 보면서 갈 수 있는 곳(1) 이면 간다.
            int nextX = x+xInd[i];
            int nextY = y+yInd[i];
            if(isTrueIndex(nextX, nextY, n, m) && maps[nextY][nextX] == 1){
                dfs(nextX, nextY, n, m, maps, dist+1);
            }
        }
        // 3. 갈 수 있는 곳이 없으면 return해서 돌아간다.
        return;
    }
    
    public boolean isTrueIndex(int x, int y, int n, int m){
        if((x>=0 || x<n) && (y>=0 || y<m)){
            return true;
        }
        return false;
    }
}
```

아무리 봐도 StackOverflow 걸릴 부분이 없는데 뭘까.. return도 알맞게 잘 잡아 뒀는데

이런 바보같은 **방문 체크 안했자나!!!!!**

그리고 저거 list or이면 안된다.

## 그래서 고친 풀이
```java
import java.util.*;
import java.lang.*;

class Solution {
    public static int[] xInd = {0,0,1,-1};
    public static int[] yInd = {1,-1,0,0};
    public static int answer = Integer.MAX_VALUE;
    public static int m;
    public static int n;
    
    public int solution(int[][] maps) {
        m = maps.length;   // y
        n = maps[0].length;    // x
        boolean[][] isVisit = new boolean[m][n];
        
        // 1. 0,0에서 출발한다.
        dfs(0, 0, maps, isVisit, 1);
        // 5. answer가 여전히 Integer.MAX_VALUE면 값이 없는 것이므로 -1을 넣는다.
        if(answer == Integer.MAX_VALUE){
            answer = -1;
        }
        return answer;
    }
    
    public void dfs(int x, int y, int[][] maps, boolean[][] isVisit, int dist){
        // 4. (n,m)에 도착하면 거리 min 값 비교해서 채운다.
        if(x == n-1 && y == m-1){
            answer = Math.min(dist, answer);
            return;
        }
        for(int i = 0; i < 4; i++){
            // 2. x,y 보면서 갈 수 있는 곳(1) 이면 간다.
            int nextX = x+xInd[i];
            int nextY = y+yInd[i];
            if(isTrueIndex(nextX, nextY) && !isVisit[nextY][nextX] && maps[nextY][nextX] == 1){
                isVisit[nextY][nextX] = true;
                dfs(nextX, nextY, maps, isVisit, dist+1);
                isVisit[nextY][nextX] = false;     // 백트래킹
            }
        }
        // 3. 갈 수 있는 곳이 없으면 return해서 돌아간다.
        return;
    }
    
    public boolean isTrueIndex(int x, int y){
        if((x>=0 && x<n) && (y>=0 && y<m)){
            return true;
        }
        return false;
    }
}
```

백트래킹의 개념을 헷갈려서 좀 헤맨 부분이 있다.

다시 돌아가야 하는거라, 재귀가 마무리 되고 나왔을 때 되돌려야 하는 것이다!!!!!

**return전에 되돌리는게 아니라**

return했을때 돌아가는 위치에서 되돌려야 하는 것이다!!!!!!!!!!!

> 백트래킹 : 이 경로 탐색 끝났으니, 다른 경로에서 이 노드를 다시 쓸 수 있게 원상복구

가지치기랑은 다른 느낌이다!!

### 정확성 테스트
```java
테스트 1 〉	통과 (0.07ms, 83.7MB)
테스트 2 〉	통과 (0.05ms, 72.3MB)
테스트 3 〉	통과 (0.07ms, 84.8MB)
테스트 4 〉	통과 (0.05ms, 84.4MB)
테스트 5 〉	통과 (0.11ms, 76.2MB)
테스트 6 〉	통과 (0.42ms, 71.2MB)
테스트 7 〉	통과 (0.92ms, 74.5MB)
테스트 8 〉	통과 (0.07ms, 84.6MB)
테스트 9 〉	통과 (0.84ms, 82.3MB)
테스트 10 〉	통과 (0.72ms, 78MB)
테스트 11 〉	통과 (0.09ms, 71.6MB)
테스트 12 〉	통과 (0.04ms, 77.2MB)
테스트 13 〉	통과 (0.21ms, 83.8MB)
테스트 14 〉	통과 (0.10ms, 82.7MB)
테스트 15 〉	통과 (0.14ms, 79.7MB)
테스트 16 〉	통과 (0.04ms, 78.2MB)
테스트 17 〉	통과 (0.73ms, 73.1MB)
테스트 18 〉	통과 (0.06ms, 75.7MB)
테스트 19 〉	통과 (0.04ms, 85.8MB)
테스트 20 〉	통과 (0.02ms, 70.7MB)
테스트 21 〉	통과 (0.05ms, 75.5MB)
```

### 효율성 테스트

```java
테스트 1 〉	실패 (시간 초과)
테스트 2 〉	실패 (시간 초과)
테스트 3 〉	실패 (시간 초과)
테스트 4 〉	실패 (시간 초과)
```

앟!

## 참고 후 풀이
백트래킹 같은 경우는 **모든 경우의 수를 도는 것**이 목표이다.

그러나, 최단거리의 경우는 명확하게 **가장 짧은 거리**를 구하는 것이 목표이다.

즉, 최단거리 문제를 백트래킹 탐색으로 풀면, 당연히 이미 최단 거리가 나왔는데도 또 구해야 하는 문제가 생기는 것이다...

그러므로 최단거리를 구하는 문제에서는, Queue를 사용해서 넓이 우선 탐색을 하는 BFS를 이용해준다.

```java
import java.util.*;
import java.lang.*;

class Node{
    int x;
    int y;
    int dist;

    Node(int x, int y, int dist){
        this.x = x;
        this.y = y;
        this.dist = dist;
    }
}

class Solution {
    public static int[] xInd = {0,0,1,-1};
    public static int[] yInd = {1,-1,0,0};
    
    public ArrayDeque<Node> init(ArrayDeque<Node> queue, boolean[][] isVisit){
        queue.addLast(new Node(0,0,1));
        isVisit[0][0] = true;
        return queue;
    }
    
    public int solution(int[][] maps) {
        int answer = 0;
        int m = maps.length;   // y
        int n = maps[0].length;    // x
        ArrayDeque<Node> queue = new ArrayDeque<>();
        boolean[][] isVisit = new boolean[m][n];
        
        // 1. 0,0에서 출발한다.
        queue = init(queue, isVisit);
        // 2. x,y 보면서 갈 수 있는 곳(1) 이면 간다.
        answer = bfs(queue, isVisit, n, m, maps);
        // 4. queue가 비었는데 answer가 0이면 -1
        return answer;
    }
    
    public int bfs(ArrayDeque<Node> queue, boolean[][] isVisit, int n, int m, int[][] maps){
        while(!queue.isEmpty()){
            Node top = queue.pollFirst();
            // 3. n,m에 도달하면 dist를 출력한다.
            if(top.x == n-1 && top.y == m-1){
                return top.dist;
            }
            for(int i = 0; i<4; i++){
                int newX = top.x + xInd[i];
                int newY = top.y + yInd[i];
                if(isTrueIndex(n, m, newX, newY) && maps[newY][newX] == 1 && !isVisit[newY][newX]){
                    queue.addLast(new Node(newX,newY,top.dist+1));    // 거리 하나 증가
                    isVisit[newY][newX] = true;
                }
            }
        }
        return -1;
    }
    
    public boolean isTrueIndex(int n, int m, int x, int y){
        if((x>=0 && x<n) && (y>=0 && y<m)){
            return true;
        }
        return false;
    }
}
```

풀고나서 좀 지저분 한 것 같아서 코드를 method로 분리하는 것까지 좀 해봤다…

- Java는 **참조 전달**이라 queue를 return할 필요 없다고 한다!!!! 이거 잊은 개념 같아서 다시 보려고 한다.

> Primitive 타입은 값 복사 전달, 
> 
> 객체는 (Collections, String 등)은 참조 전달인 것이다. 잊어먹음...기본이니 잊지 마라!!!
> 
> 즉, 주솟값을 가지기 때문에 당연히 queue를 따로 return해서 갱신할 필요가 없다.

------

## 최종 풀이

```java
import java.util.*;
import java.lang.*;

class Node{
    int x;
    int y;
    int dist;

    Node(int x, int y, int dist){
        this.x = x;
        this.y = y;
        this.dist = dist;
    }
}

class Solution {
    public final static int[] xInd = {0,0,1,-1};
    public final static int[] yInd = {1,-1,0,0};
    
    public void init(ArrayDeque<Node> queue, boolean[][] isVisit){
        queue.addLast(new Node(0,0,1));
        isVisit[0][0] = true;
    }
    
    public int solution(int[][] maps) {
        int answer = 0;
        int m = maps.length;   // y
        int n = maps[0].length;    // x
        ArrayDeque<Node> queue = new ArrayDeque<>();
        boolean[][] isVisit = new boolean[m][n];
        
        // 1. 0,0에서 출발한다.
        init(queue, isVisit);
        // 4. queue가 비었는데 answer가 0이면 -1
        return bfs(queue, isVisit, n, m, maps);
    }
    
    public int bfs(ArrayDeque<Node> queue, boolean[][] isVisit, int n, int m, int[][] maps){
        while(!queue.isEmpty()){
            Node top = queue.pollFirst();
            // 3. n,m에 도달하면 dist를 출력한다.
            if(top.x == n-1 && top.y == m-1){
                return top.dist;
            }
            for(int i = 0; i<4; i++){
                int newX = top.x + xInd[i];
                int newY = top.y + yInd[i];
                // 2. x,y 보면서 갈 수 있는 곳(1) 이면 간다.
                if(isTrueIndex(n, m, newX, newY) && maps[newY][newX] == 1 && !isVisit[newY][newX]){
                    queue.addLast(new Node(newX,newY,top.dist+1));    // 거리 하나 증가
                    isVisit[newY][newX] = true;
                }
            }
        }
        return -1;
    }
    
    public boolean isTrueIndex(int n, int m, int x, int y){
        if((x>=0 && x<n) && (y>=0 && y<m)){
            return true;
        }
        return false;
    }
}
```

### 정확성 테스트

```java
테스트 1 〉	통과 (0.29ms, 84.5MB)
테스트 2 〉	통과 (0.27ms, 72.8MB)
테스트 3 〉	통과 (0.30ms, 89.3MB)
테스트 4 〉	통과 (0.34ms, 88.5MB)
테스트 5 〉	통과 (0.30ms, 81.4MB)
테스트 6 〉	통과 (0.43ms, 72.2MB)
테스트 7 〉	통과 (0.48ms, 83.8MB)
테스트 8 〉	통과 (0.32ms, 79.2MB)
테스트 9 〉	통과 (0.33ms, 79MB)
테스트 10 〉	통과 (0.46ms, 75.7MB)
테스트 11 〉	통과 (0.31ms, 82.9MB)
테스트 12 〉	통과 (0.29ms, 81.3MB)
테스트 13 〉	통과 (0.33ms, 70.7MB)
테스트 14 〉	통과 (0.30ms, 82.7MB)
테스트 15 〉	통과 (0.31ms, 81.9MB)
테스트 16 〉	통과 (0.36ms, 77MB)
테스트 17 〉	통과 (0.34ms, 82MB)
테스트 18 〉	통과 (0.27ms, 85.1MB)
테스트 19 〉	통과 (0.29ms, 89MB)
테스트 20 〉	통과 (0.29ms, 69MB)
테스트 21 〉	통과 (0.28ms, 80.7MB)
```

### 효율성 테스트

```java
테스트 1 〉	통과 (7.76ms, 54.9MB)
테스트 2 〉	통과 (5.33ms, 56.3MB)
테스트 3 〉	통과 (5.79ms, 54.3MB)
테스트 4 〉	통과 (4.67ms, 54.2MB)
```

굳…..