## 내 풀이
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayDeque;
import java.util.StringTokenizer;

public class Main {
    public static final int[] posX = {0, 0, -1, 1};
    public static final int[] posY = {-1, 1, 0, 0};
    public static int m;
    public static int n;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        // 1. isVisit으로 배열 만든다.
        boolean[][] isVisit = new boolean[n][m];
        char[][] map = new char[n][m];

        for (int i = 0; i < n; i++) {
            map[i] = br.readLine().toCharArray();
        }

        Main sol = new Main();
        System.out.println(sol.bfs(isVisit, map));
    }

    public boolean isTrueInd(int x, int y) {
        if ((0 <= x && x < m) && (0 <= y && y < n)) {
            return true;
        }
        return false;
    }

    public void addQueue(ArrayDeque<int[]> queue, boolean[][] isVisit, int x,
                         int y, int depth, int isWall) {
        // 4. Queue에 x,y,depth, 1을 썼는지 여부를 넣어서 배열을 만들고
        int[] node = {x, y, depth, isWall};
        queue.addLast(node);
        isVisit[y][x] = true;
    }

    public boolean canAdd(int isWall, int mapNumber) {
        // 5. 여기서 1을 쓰지 않았을 경우 1이어도 넣을 수 있고 아니면 넘어간다.
        if (isWall == 1 && mapNumber == 1) {    // 이미 벽 한 번 통과했는데 또 벽
            return false;
        }
        return true;
    }

    public int bfs(boolean[][] isVisit, char[][] map) {
        // 2. Queue를 생성한다.
        ArrayDeque<int[]> queue = new ArrayDeque<int[]>();
        addQueue(queue, isVisit, 0, 0, 1, 0); //초기 위치 넣기
        // 3. for문으로 4방향을 전부 탐구한다.
        while (!queue.isEmpty()) {
            int[] top = queue.pollFirst();

            int topX = top[0];
            int topY = top[1];
            int topDepth = top[2];
            int isWall = top[3];
            // 6. 결과적으로 끝인 m,n에 도달하면 끝낸다.
            if (topX == m - 1 && topY == n - 1) {
                return topDepth;
            }

            for (int i = 0; i < 4; i++) {
                int nextX = topX + posX[i];
                int nextY = topY + posY[i];
                // 앞에서 부터 검사하니까 그냥 map 넣기.
                if (isTrueInd(nextX, nextY) && !isVisit[nextY][nextX] && canAdd(isWall, map[nextY][nextX] - '0')) {
                    if(isWall == 1){
                        addQueue(queue, isVisit, nextX, nextY, topDepth + 1, isWall);
                    }else{
                        addQueue(queue, isVisit, nextX, nextY, topDepth + 1, map[nextY][nextX] - '0');
                    }
                }
            }
        }
        // 7. Queue가 다 비었으면 return -1한다.
        return -1;
    }
}
```
- 사실 1을 한번만 뚫을 수 있는거라 이것만 체크하고 bfs로 풀어내면 된다고 생각했다.
- 근데 13%까지만 가고 틀려서...내가 보기엔 로직에 구멍이 없는거 같아서 이유를 물어봄 
- 이건 조언을 보니, 벽을 뚫었느냐 말았느냐를 3차원으로 봐야 한다고 한다.
- 지금 싸피 대비하는 수준에서 풀 문제는 아닌거 같으니 나중에 다시 오기로 했다.

