# Intro

나야 백준을 취미로 풀어왔으니 기본적인 개념이나 이런건 다 알다만..

실전 대비가 전혀 되어 있지 않다.

그러므로 이 책을 통해서 코테를 제로부터 다시 준비하면서

이제는 실전에서 진짜 실력을 발휘할 수 있도록 준비해볼까, 한다.

# Start

## 00. 코딩 테스트를 준비하기 전에..

### 1. 타인의 풀이를 보면, 사고를 넓힐 수 있다.

- 다른 사람이 작성한 코드를 보면, 자연스럽게 다양한 문제 풀이 접근 방식이나 코딩 스킬을 습득할 수 있다. 다만, 중요한 것은 **숏코딩**이 꼭 잘 푼 풀이는 아니라는 것이다!!!!

### 2. 나만의 테스트 케이스를 추가하자.

- 프로그래머스에 나오는 테케는 주로 문제를 단편적으로 설명해주는 간단한 테케가 대부분이다.
- 보통, 문제를 풀고 걸리는 부분은 히든 테케라고 불리는 숨겨진 테케인 경우가 많다.
- 내가 가장 부족한 부분이 이 부분인데,,,그러므로 충분한 시간을 들여 문제를 분석한 다음 코드로 구현하기 전에 여러 예외 상황을 충분히 확인할 수 있도록 나만의 테스트 케이스를 추가하는 것이 좋다.

### 3. 나만의 언어로 기록하라.

- 과연 문제를 이해했다고, 정말 이해한 것이 맞을까?
- 정말 이해했는지 확인하기 위해서는 반드시 나만의 언어로 정리하는 습관을 들이는 것이 중요하다.
- 항상 펜과 노트를 두고, 개념이던 문제던 나만의 언어로 정리하는 습관을 들이자~

## 01. 코딩 테스트 효율적으로 준비하기

### 1. 문제를 쪼개서 분석해라

- 문제 양 자체가 많은 경우가 대부분이다. 특히 구현의 경우,,,, 그러므로 문제를 동작 단위로 쪼개서 분석하는 것이 유리하다.

### 2. 제약 사항을 파악하고 테스트 케이스를 추가해라.

- 문제는 보통 제약 사항이 있기 때문에 이를 미리 정리해두고 고려해서 테스트 케이스를 추가하는 연습을 하는 것이 좋다.

### 3. 입력값을 분석해라

- 알고리즘의 시간 복잡도는 보통 입력값이 결정하는 경우가 많다.
- 그러므로, 입력값의 크기를 확인하면 문제를 제한 시간 내에 풀 수 있는 알고리즘과 그렇지 않은 알고리즘을 미리 걸러낼 수 있다.
    - 그래서 구현 전에는 반드시 입력값을 분석하는 것이 좋다.

### 4. 그리디하게 접근할때는 근거를 명확히 해라.

- 이 문제가 그리디한 문제인지, 완전탐색으로 전체 경우의 수를 다 파악해야 하는 문제인지 파악하는 것이 중요하다.
- 예를 들어, 가장 작은 숫자로 특정 금액을 만들어야 하는 문제의 경우도, 무조건 큰 값을 먼저 빼서 답을 구할 수 없는 경우가 존재한다.
    - 이런 경우, 그리디한 접근법으로는 풀 수 없다. 모든 경우의 수를 다 구해서 비교해야 하는 완전 탐색으로 풀어야 하는 것인데….이런 문제를 그리디한 접근법으로 해결하고자 할 경우 시간이 낭비된다.
    - 그러므로, 이 문제를 어떤 접근법으로 풀어야 하는 지를 미리 파악하는 것은 중요하다.

### 5. 데이터 흐름이나 구성을 파악해라

- 예를 들어, 데이터의 삽입이나 삭제가 빈번하게 일어나면서 최대 최소를 구해야 하는 경우는, 트리 형태의 최소힙, 최대힙을 이용하는 것이 좋기 때문에 **힙(heap)** 자료구조를 이용하는 것이 좋다.
- 또한, 데이터 값의 차이가 크면 데이터 값 자체를 배열의 인덱스로 활용하는 전형적인 풀이법은 사용하지 않는 것이 좋다. 공간의 낭비가 너무 크기 때문이다.
- 이처럼 문제를 보고, 효율적인 자료구조를 선택해서 문제를 푸는 것도 좋다.

### 6. 의사 코드로 문제를 설계하는 연습을 하라.

- 의사코드로 문제를 설계하는 연습을 할 때 중요한 것은, 설계를 중점을 하되, 구현을 목표로 하지는 말라는 것이다.
- 또한, 이를 토대로 코드를 구현할 것이므로, 의사 코드는 문제 해결 순서대로 작성 하는 것이 좋다.

## 02. 시간복잡도 계산하기

### 1. 시간 복잡도란?

알고리즘의 성능을 나타내는 지표로, 입력 크기에 대한 연산 횟수의 상한을 의미한다. 시간복잡도는 낮으면 낮을 수록 좋다!

여기서, 점근적 표기법의 상한을 이용하는 것을 최악의 경우를 점치는 표기법이라고 하여 **빅오 표기법이라고 한다.**

### 2. 빅오 표기법 자세히 알아보기

- 점근적 상한이란, 입력 크기가 충분히 커졌을 때, 함수가 넘지 못하는 한계를 의미한다.
- 그래서 점근적 상한을 만족하면서 f(x)의 성능을 잘 나타내기 위해 하는 작업이 f(x)의 최고차항만 남기고 계수를 제거하는 작업이다.
  - 계수를 제거하는 이유는 f(x)에서 x에 해당하는 값이 굉장히 크기 때문에, 앞에 붙는 계수는 최종 연산 횟수를 구할 때 영향력이 크지 않아 크게 의미가 없기 때문이다.
- 즉, 우리가 풀어야 할 문제들은 입력값이 충분히 크다는 것이 전제되어 있으므로, 특정 시점 이후에 항상 g(x)가 f(x)보다 크다면 특정 시점 이전의 상황은 고려하지 않아도 되는 것이다.

### 3. 시간 복잡도를 코딩 테스트에 활용하는 방법

- 코딩 테스트 문제에는 제한 시간이 있으므로, 문제를 분석한 후에 빅오 표기법을 활용해서 해당 알고리즘을 적용했을때 제한 시간 내에 출력값이 나올 수 있을지를 확인해 볼 수 있다.
- 제한 시간 1초 기준으로, N의 가용범위를 각 연산별로 정리하자면 다음과 같다.

| 시간 복잡도 | N의 가용 범위 |
| --- | --- |
| O(N!) | 10 |
| O(2^N) | 20~25 |
| O(N^3) | 200~300 |
| O(N^2) | 3000~5000 |
| O(NlogN) | 100만 |
| O(N) | 1000~2000만 |
| O(logN) | 10억 이상 |

## 04. 코딩 테스트 필수 문법

- 프리미티브 타입 : int, long, float, double
- 레퍼런스 타입 : Integer, Long, Float, Double
- 레퍼런스 타입의 경우는 참조형 변수이므로, 프리미티브 타입보다 연산 속도가 더 느리다. 그러므로 알고리즘 연산에서는 프리미티브 타입을 활용하는 것이 좋다.

### 부동 소수형 - 앱실론을 포함한 연산에 주의해라

- 자바의 경우는 부동 소수형 데이터를 이진법으로 표현하기 때문에 표현 과정에서 오차가 발생한다.

> 이를 **앱실론**이라고 한다.
>
- 그러므로, 코딩 테스트에서 부동 소수형 데이터를 다룰 일이 생겼을 때는 이 앱실론을 항상 생각해야 한다.
- 부동 소수형 데이터를 활용하는 문제는 오차 허용 범위를 언급하는 경우가 많다. 그러므로 문제를 분석할 때 꼭 이 부분을 체크하는 것이 좋다.

### 람다식

```java
public static void main(String[] args){
	Arrays.sort(nodes, (o1, o2) -> Integer.compare(o1.cost, o2.cost));
	
	Arrays.sort(nodes, new Comparator<Node>(){
		@Override
		public int compare(Node o1, Node o2){
			return Integer.compare(o1.cost, o2.cost);
		}
	});
}
```

- Integer.compare(o1.cost, o2.cost)같은 경우는, 다음과 같이 작동한다.
  - x<y이면 -1반환
  - x>y이면 1 반환
  - x==y이면 0 반환
- 정렬 조건을 할 때 뺄셈을 하는 경우, 오버 플로우가 발생하는 경우도 있기 때문에 이렇게 compare로 비교를 해 주는 것이 좋다.

### 스트림

- 자바에서 스트림이란, 데이터의 흐름을 의미한다.
  - 스트림은 데이터의 소스를 추상화하고, 데이터를 다루는데 유용한 메서드를 정의해둔 것이다.
  - 다시말해, 배열 또는 컬렉션을 스트림으로 변환하면 for문 등의 반복문을 사용하지 않고도 컬렉션의 데이터를 배열에 담아서 반환하거나 특정 조건에 따라 필터링하는 등 코드의 양을 줄이고 가독성을 향상시킬 수 있다.

> 다만, 이것은 개발 관점에서의 이야기이고, 단일 스레드 환경의 코딩 테스트 관점에서는 시간 복잡도 측면에서 for문 등의 반복문과 스트림은 성능에 큰 차이가 없다.
- 그러나, 스트림에서 제공하는 메서드는 대부분 O(N)의 성능을 보여주므로, 스트림을 대체할 로직을 for문으로 직접 작성한다면 동일한 O(N) 수준의 로직으로 작성해야 수행 시간에 차이가 없다.